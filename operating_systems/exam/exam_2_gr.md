# Τέσσερις διεργασίες ανταγωνίζονται για τρία είδη πόρων A,B,C.

Έστω οι παρακάτω πίνακες οι οποίοι αναπαριστούν:

##   πόσους πόρους από κάθε είδος μπορεί να απαιτήσει κατά μέγιστο κάθε διεργασία 

Ο πίνακας "Μέγιστες Απαιτήσεις" αναφέρεται στην ποσότητα των πόρων ανά είδος που μπορεί
να απαιτήσει κάθε διεργασία:


## πόσοι πόροι από κάθε είδος έχουν ήδη εκχωρηθεί σε κάθε διεργασία

Ο πίνακας "Εκχωρημένοι Πόροι" δείχνει πόσοι πόροι από κάθε είδος έχουν
ήδη εκχωρηθεί σε κάθε διεργασία:

## 	πόσοι πόροι απομένουν από κάθε είδος (διαθέσιμοι πόροι)

Ο πίνακας "Διαθέσιμοι Πόροι" αναφέρεται στον αριθμό των πόρων που απομένουν από κάθε είδος:

| Pc |Μέγιστες  Απαιτήσεις|Εκχωρημένοι  Πόροι| Διαθέσιμοι Πόροι |
|----|--------------------|------------------|------------------|
|    |    A    B    C     |    A    B    C   |     A   B    C   |
| P1 |    7    5    9     |    2    3    2   |     2   5    4   | 
| P2 |    5    4    4     |    3    2    2   |     7   9    8   | 
| P3 |   11    7    1     |    5    3    0   |                  | 
| P4 |    7    5    1     |    3    2    0   |                  |

Εξετάστε αν η παραπάνω κατάσταση είναι ασφαλής σύμφωνα με τον αλγόριθμο του Τραπεζίτη.'

Βήμα 1. Φτιάχνω τον Remaining Need πίνακα

*To find Remaining Need = Max - Allocation*

```
7-2, 5-3, 9-2 = 5,2,7
5-3, 4-2, 4-2 = 2,2,2
11-5,7-3, 1-0 = 6,4,1
7-3,5-2,1-0 = 4, 3, 1 
```

Βήμα 2. Καλώ τον τραπεζίτη (need <= work)

```
5,2,7 <= 2,5,4  (P1 False)
2,2,2 <= 2,5,4 (P2 True)
6,4,1 <= 2,5,4 (P3 False)
4, 3, 1 <= 2,5,4 (P4 False)
```

Οι εκχωρημενοι της P2 ηταν (3 2 2) και οι διαθεσιμοι (2 5 4)

```
(2,5,4) + (3,2,2) =  (5 7 6)
```

Ξανά το ίδιο που έκανα (Βήμα 2) πάνω αλλά με το (7, 9, 8).

```
5,2,7 <= 5,7,6 (P1 True)
6,4,1 <= 5,7,6 (P3 True)
4, 3, 1 <= 5,7,6 (P4 True)
```

### Απάντηση 
Η παραπάνω κατάσταση είναι ασφαλής.

# Έστω οι ακόλουθες περιοδικές διεργασίες σε ένα σύστημα πραγματικού χρόνου:

|Pc | P | D | 
|---|---|---|
|P1 | 18|9 | 
|P2 | 12|5 |

## Δείξτε πώς θα εκτελεστούν οι ανωτέρω διεργασίες στην Κ.Μ.Ε., αν εφαρμοστεί RMS.

| Processes| 0-5 | 5-12|12-17|17-24|24-29|29-33|36-41|
|----------|-----|-----|-----|-----|-----|-----|-----|
|  P1/P2   | P2  | P1  | P2  |  P1 | P2  | P1 | P2 |
|  Loss    |  0  | 2   |  0  |  4  | 0   | 0  | 0  |

(Το loss το έβαλα για να δείξω πόσα δ χάνει το P1)

##  Δείξτε πώς θα εκτελεστούν οι ανωτέρω διεργασίες στην Κ.Μ.Ε., αν εφαρμοστεί EDF.


# TODO:
| Processes| |   |     |     |     |     |     |
|----------|-----|-----|-----|-----|-----|-----|-----|
|  P1/P2   | 


## Ποιες διαφορετικές μορφές μετάφρασης διευθύνσεων (address translation) από το λογικό χώρο διευθύνσεων στο φυσικό χώρο, μπορούν να παρατηρηθούν σε συστήματα πραγματικού χρόνου;

Σε συστήματα πραγματικού χρόνου, οι διάφορες μορφές μετάφρασης διευθύνσεων που μπορούν να παρατηρηθούν
είναι η μετάφραση διευθύνσεων με βάση τον πίνακα σελίδων και η μετάφραση διευθύνσεων με βάση τον μεταφραστή (TLB).


# Αρκεί η χρήση ενός απλού μηχανισμού TSL (όπως αυτός υλοποιείται σε ένα μονο-επεξεργαστικό σύστημα) για την επίτευξη αμοιβαίου αποκλεισμού σε ένα πολύ-επεξεργαστικό σύστημα κοινής μνήμης; (εξηγείστε σύντομα). Πώς αντιμετωπίζεται το πρόβλημα αυτό στα σύγχρονα συστήματα; [1]
Ο αλγόριθμος TLS που είναι για μονο-επεξεργαστικό σύστημα δεν υπαρκεί σε ένα πολύ επεξεργαστικό σύστημα.
Στα σύγχρονα πολύ-επεξεργαστικά συστήματα, χρησιμοποιούνται πιο προηγμένοι μηχανισμοί για την επίτευξη αμοιβαίου αποκλεισμού.
Ένας τέτοιος μηχανισμός είναι οι κλειδαριές (locks), όπως οι αμοιβαίες κλειδαριές (mutex locks) ή οι κλειδαριές μεπρόθεσμης αναμονής (spin locks) τα οποία λύνουν αυτό το πρόβλημα. 



# Τι είναι το ‘κλείδωμα περιστροφής’ (spin lock), τι είναι ο ‘έξυπνος χρονοπρογραμματισμός’ και σε τι εξυπηρετεί έναντι της κλασσικής εφαρμογής της μεθόδου του ‘χρονομερισμού’;

Το spin lock είναι ένας τύπος κλειδαριάς που χρησιμοποιείται στον προγραμματισμό υπολογιστών
για την προστασία των κοινόχρηστων πόρων.
Χρησιμοποιεί busy-waiting, όπου ένα νήμα ελέγχει συνεχώς για τη διαθεσιμότητα της κλειδαριάς
μέχρι να μπορέσει να την αποκτήσει. Τα spin lock είναι κατάλληλα για μικρά κρίσιμα τμήματα
όπου ο αναμενόμενος χρόνος αναμονής είναι μικρός.

Ένας έξυπνος προγραμματιστής χρόνου είναι ένας προηγμένος αλγόριθμος προγραμματισμού 
που διαχειρίζεται αποτελεσματικά τους πόρους του συστήματος.
Προσφέρει βελτιωμένη χρήση πόρων, ανταπόκριση συστήματος και συνολική απόδοση σε σύγκριση με την κλασική κοινή χρήση χρόνου.



# Έστω 5 διεργασίες Α, Β, Γ, Δ και Ε οι οποίες καταφτάνουν τη χρονική στιγμή ‘0’ (με αυτή τη σειρά) για εκτέλεση σε ένα πολυεπεξεργαστικό σύστημα κοινής μνήμης με 12 επεξεργαστές (C1…C12). Έστω επίσης ότι οι διεργασίες αυτές αποτελούνται: 

* η Α από 5 νήματα των 16ms (Α1...Α5)
* η Β από 6 νήματα των 12ms (Β1...Β6)
* η Γ από 3 νήματα των 4ms (Γ1...Γ3)
* η Δ από 6 νήματα των 20 ms (Δ1...Δ6)
* η Ε από 2 νήματα των 8 ms (Ε1…Ε2).

TODO:

## Δείξτε πώς θα εκτελεστούν τα νήματα των διεργασιών αυτών στους 12 επεξεργαστές καθώς και σε πόσο χρόνο αναμένεται να έχει ολοκληρωθεί η εκτέλεση όλων, αν εφαρμοστεί η μέθοδος του χωρομερισμού (space sharing) [με λογική SJF] 

### τι σειρά υπαγορεύει ο SJF;

Ο αλγόριθμος SJK υπαγορεύει ότι η επόμενη εργασία που θα εκτελεστεί είναι αυτή με τον μικρότερο αναμενόμενο χρόνο εκτέλεσης.

# Συμπληρώστε τον πίνακα με ΝΑΙ και ΟΧΙ (ανάλογα με το αν υποστηρίζονται ‘Παραλληλισμός’ και ‘Ανασταλτικές Κλήσεις’ σε κάθε ένα από τα αναφερόμενα μοντέλα)

|            Μοντέλο            |Ανασταλτικές Κλήσεις| Παραλληλισμός |
|-------------------------------|--------------------|---------------|
|Μηχανή Πεπερασμένων Καταστάσεων|         OXI        |      NAI      |
|Μονονηματικές Διεργασίες       |         NAI        |      OXI      |
|Νήματα Ελέγχου                 |         NAI        |      NAI      |



# Εξηγείστε σύντομα (δίνοντας και κώδικα) πώς γίνεται ‘barrier synchronization’

## με χρήση μετρητή (counter barrier implementation) 

χρησιμοποιείται για να παρακολουθεί τον αριθμό των νημάτων ή των διεργασιών που έχουν
φτάσει σε ένα συγκεκριμένο σημείο συγχρονισμού που ονομάζεται φράγμα.

```
int count = 0; 
process Worker [i = 1 to n] { 
	while (true) { 
		code to implement task i; 
		< count = count + 1; > 
		/* critical section */ 
		while (count != n) skip; 
	} 
}
```

## με χρήση συντονιστή (using coordinator process)

ο coordinator ελέγχει κεντρικά αν έφτασαν όλα στο σημείο φράγματος.

```
int arrive[1:n] = ([n] 0), continue[1:n] = ([n] 0);
process Worker[i = 1 to n] {
	while (true) {
		code to implement task i;
		arrive[i] = 1;
		while (continue[i] != 1) skip;
		continue[i] = 0;
	}
}

process Coordinator {
	while (true) { 
		for [i = 1 to n] { 
			while (arrive[i] != 1) skip;
			arrive[i] = 0;
		}
		for [i = 1 to n] continue[i] = 1;
	} 
}
```

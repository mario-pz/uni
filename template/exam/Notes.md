
**Ορισμός κατανεμημένου συστήματος**

Μια συλλογή από αυτόνομους υπολογιστές που συνδέονται μεταξύ τους μέσω ενός δικτύου και
χρησιμοποιούν ειδικά σχεδιασμένο λογισμικό για την παροχή ενοποιημένων υπολογιστικών
υπηρεσιών. Οι διεργασίες που εκτελούνται από τους δικτυωμένους υπολογιστές, επικοινωνούν
μεταξύ τους και συντονίζουν τις κινήσεις τους μέσω της ανταλλαγής μηνυμάτων.

**Ποια τα χαρακτηριστικά των κατανεμημένων συστημάτων**

- Οι διαφορές μεταξύ των διαφόρων υπολογιστών και οι τρόποι με τους οποίους αυτοί
    επικοινωνούν παραμένουν κρυφοί για τους χρήστες.
- Το ίδιο ισχύει και για την εσωτερική οργάνωση των κατανεμημένων συστημάτων.
- Οι χρήστες και οι εφαρμογές μπορούν να αλληλεπιδρούν με ένα κατανεμημένο σύστημα με
    συνεπή και ομοιόμορφο τρόπο, ανεξάρτητα από το που και πότε πραγματοποιείται η
    αλληλεπίδραση.
- Τα κατανεμημένα συστήματα θα πρέπει να επιτρέπουν με σχετική ευκολία την επέκτασή
    τους ή την προσαρμογή της κλίμακας του μεγέθους τους.

**Περιγράψτε τι σημαίνει κατανεμημένη επεξεργασία**.

- Πολλοί υπολογιστικοί κόμβοι συνεργάζονται χαλαρά (loosely coupled nodes)
- Στόχος η κατανομή υπηρεσιών, εφαρμογών, επεξεργαστικής ισχύος, ή δεδομένων
- Δεύτερος στόχος είναι η ταχύτητα
- Η επικοινωνία δεν είναι συνήθως συχνή
- Παρότι οι κόμβοι είναι ετερογενείς το δίκτυο είναι τυποποιημένο
- Οι κόμβοι προστίθενται στο δίκτυο με βάση τη γεωγραφική τους θέση

**Ποια θέματα έχει η κατανεμημένη επεξεργασία;**

- Κατανομή δεδομένων: διαχείριση πολλαπλών αντιγράφων
- Διαχείριση ταυτοχρονισμού: κλείδωμα, αδιέξοδα
- Δίκτυο: ταχύτητα, τυποποίηση, επίπεδα ασφάλειας
- Ανοχή σε σφάλματα


**Ποιες οι διαφορές της κατανεμημένης με την παράλληλη επεξεργασία.**

```
Παράλληλα Συστήματα Κατανεμημένα Συστήματα
Στόχος Επιτάχυνση 1. Τοπολογική κατανομή εφαρμογών,
επεξεργαστών ή δεδομένων
```
2. Ταχύτητα
Δίκτυο Έμφαση στην ταχύτητα Ευρείας χρήσης (π.χ. ISDN, Οπτικές ίνες,
μισθωμένες γραμμές, Ethernet)
Εφαρμογές Επιστημονικές εξομοιώσεις Υπηρεσίες, Βάσεις δεδομένων
Αποστάσεις <1m >1m συχνά >1Km
Τοπολογία Γεωμετρική Αυθαίρετη
Κόμβοι Ομοιογενείς Πιθανώς ετερογενείς

**Μοντέλο αρχιτεκτονικής** client-server **και η εξέλιξη του**.

- Ο πελάτης στέλνει αιτήσεις στον εξυπηρετητή
- Ο εξυπηρετητής παρέχει πόρους ή υπηρεσίες
- Οι πελάτες δεν έχουν καμία μεταξύ τους επικοινωνία
- Πλεονέκτημα: Εύκολη υλοποίηση - διαχείριση
- Μειονέκτημα: Ένα σημείο αποτυχίας, δύσκολη κλιμάκωση
- E-mail, www, ftp, DNS, κλπ.

**Τι είναι** thin **και τι είναι** fat clients.

Thin client: O πελάτης εκτελεί τη λιγότερο δυνατή επεξεργασία. Η βαριά επεξεργασία εκτελείται
στον εξυπηρετητή

- Λιγότερες απαιτήσεις σε hardware και τεχνολογία
- Καθόλου διαχειριστικό κόστος
- Καθυστέρηση δικτύου

Fat client: Το μεγαλύτερο μέρος της επεξεργασίας εκτελείται από τον πελάτη

- Υψηλές δυνατότητες τοπικά
- Μικρότερη εξάρτηση από το δίκτυο
- Μεγαλύτερο κόστος διαχείρισης-συντήρησης

**Τι είναι τα** peer-to-peer **μοντέλα;**

- Όλοι οι κόμβοι είναι ισότιμοι (clients & servers)
- Επικοινωνούν μεταξύ τους (Robustness, scalability, αυτό-οργάνωση Δύσκολη διαχείριση,
    ασφάλεια)
- SETI@home, Gnutella, BitTorrent, JXTA, skype, κλπ.


**Τι είναι το** Middleware - **Ενδιάμεσο Λογισμικό**

Προκειμένου να υποστηριχτούν διαφορετικά είδη υπολογιστών και δικτύων και παράλληλα να
προσφέρουν μια ομοιόμορφη εικόνα στους τελικούς χρήστες, τα ΚΣ συνήθως αποτελούνται από
ένα επίπεδο λογισμικού, το middleware.

Το λογισμικό αυτό τοποθετείται λογικά μεταξύ ενός υψηλότερου επιπέδου που αποτελείται από
τους χρήστες και τις εφαρμογές και ενός χαμηλότερου επιπέδου που αποτελείται από λειτουργικά
συστήματα.

![[middleware.png]]


**Ποιοι οι βασικοί στόχοι των κατανεμημένων συστημάτων και τι είναι το καθένα αναφορικά.**

- Να συνδέει εύκολα τους χρήστες με τους πόρους (συνδεσιμότητα)
- Να κρύβει το γεγονός ότι οι πόροι είναι κατανεμημένοι σε δίκτυο (διαφάνεια)
- Να υποστηρίζει ανοικτές αρχιτεκτονικές (openness)
- Να είναι επεκτάσιμο (scalability)
    ✓ στο μέγεθος
    ✓ γεωγραφικά
    ✓ διαχειριστικά


**Συνδεσιμότητα**

Σκοπός :

- εύκολη προσπέλαση απομακρυσμένων πόρων
- να επιτρέπει τον διαμοιρασμό αυτών των πόρων με πολλούς χρήστες με ένα ελεγχόμενο
    τρόπο
- Διευκόλυνση της συνεργασίας (computer-supported cooperative work/games), π.χ.
    groupware, e-commerce

Η αυξανόμενη συνδεσιμότητα μπορεί να οδηγήσει σε ανεπιθύμητη επικοινωνία (π.χ. Spam)

και προβλήματα ασφάλειας και πρόσβασης σε προσωπικά δεδομένα.

**Διαφάνεια**

Ένα κατανεμημένο σύστημα που μπορεί να εμφανίζεται στους χρήστες και τις εφαρμογές σαν ένα
ενιαίο υπολογιστικό σύστημα χαρακτηρίζεται ως διαφανές (transparent).

Σκοπός:

Απόκρυψη του γεγονότος ότι οι διεργασίες και οι πόροι του είναι από φυσική άποψη
κατανεμημένοι σε πολλούς υπολογιστές.

Η διαφάνεια δεν είναι πάντα εφικτή ή εύκολα υλοποιήσιμη.

Εξαρτάται από την αρχιτεκτονική του ΚΣ και την απόδοση του συστήματος, π.χ.

- αντίγραφα βάσεων δεδομένων,
- ταχύτητα μετάδοσης σήματος,

## Ανοικτή Αρχιτεκτονική

Αποτελεί σημαντικό παράγοντα:

Διαλειτουργικότητας (interoperability): Χαρακτηρίζει το κατά πόσον δύο υλοποιήσεις συστημάτων
ή στοιχείων που προέρχονται από διαφορετικούς κατασκευαστές μπορούν να συνυπάρχουν και
να συνεργάζονται βασιζόμενες απλώς η μία στις υπηρεσίες της άλλης, όπως αυτές καθορίζονται
από ένα κοινό πρότυπο.

Φορητότητας (portability): Χαρακτηρίζει το κατά πόσον μια εφαρμογή που έχει αναπτυχθεί για ένα
κατανεμημένο σύστημα Α μπορεί να εκτελεστεί χωρίς τροποποιήσεις σε ένα διαφορετικό
κατανεμημένο σύστημα Β, το οποίο υλοποιεί τις ίδιες διασυνδέσεις με το Α.

Ευελιξίας (flexibility):

- δυνατότητα ένα σύστημα να διαμορφωθεί από διαφορετικά στοιχεία υλοποιημένα από
    διαφορετικούς κατασκευαστές
- Το σύστημα είναι μία συλλογή επιμέρους στοιχείων τα οποία μπορούν εύκολα να
    προσαρμοστούν ή να αντικατασταθούν


**Επεκτασιμότητα (Scalability)**

Η επεκτασιμότητα αποτελεί έναν από τους σημαντικότερους σχεδιαστικούς στόχους για τους
κατασκευαστές κατανεμημένων συστημάτων

Η επεκτασιμότητα μετριέται σε τρεις διαστάσεις:

- μέγεθος: μπορούμε να προσθέσουμε στο σύστημα περισσότερους χρήστες και πόρους
- γεωγραφική επεκτασιμότητα: οι χρήστες και οι πόροι είναι δυνατόν να βρίσκονται σε
    μεγάλες αποστάσεις μεταξύ τους
- διαχειριστική επεκτασιμότητα: η διαχείριση του συστήματος μπορεί να παραμένει εύκολη
    ακόμα και αν αυτό εκτείνεται σε πολλούς διαχειριστικά ανεξάρτητους οργανισμούς.

```
Επεκτασιμότητα - Μέγεθος
```
Προβλήματα

Κεντρικός server για όλους τους χρήστες (centralized server)

- Ανασχετικός παράγοντας καθώς ο αριθμός των χρηστών αυξάνει
- Υπερφόρτωση επικοινωνίας
- Όμως υπάρχουν περιπτώσεις όπου η χρήση πολλαπλών servers δεν είναι δυνατή (π.χ.
    λόγω ασφάλειας)

Συγκεντρωτικά data (centralized data)

- Υπερφόρτωση επικοινωνίας, π.χ. online index (central DNS)

Συγκεντρωτικοί Αλγόριθμοι (centralized algorithms)

- Κεντρικός αλγόριθμος δρομολόγησης με βάση το σύνολο των μηνυμάτων που πρέπει να
    σταλούν

Αποκεντρωμένοι αλγόριθμοι

- Κανένα μηχάνημα δεν έχει πλήρη πληροφόρηση για τη συνολική κατάσταση του
    συστήματος
- Κάθε μηχανή παίρνει αποφάσεις στηριζόμενη σε πληροφορίες που είναι διαθέσιμες τοπικά
- Δυσλειτουργία μίας μηχανής δεν επηρεάζει τον αλγόριθμο
- Δεν υπάρχει παραδοχή για καθολικό ρολόϊ

```
Επεκτασιμότητα – Γεωγραφία
```
Σύγχρονη επικοινωνία: Ο client που ζητά μία υπηρεσία μπλοκάρεται μέχρι να πάρει απάντηση


![[sync_n_async.png]]
![[Pasted image 20230527212357.png]]


- Η προσέγγιση δουλεύει καλά σε LANs (επικοινωνία απαιτεί μερικές εκατοντάδες
    μικροδευτερόλεπτα) όχι όμως σε WANs (επικοινωνία απαιτεί εκατοντάδες χιλιοστά
    δευτερολέπτου)
- Οι διαδραστικές εφαρμογές έχουν χρονικές απαιτήσεις

Σε WANs η επικοινωνία είναι point-to-point και δεν είναι τόσο αξιόπιστη π.χ. εντοπισμός μίας
δικτυακής υπηρεσίας (service location)

Συγκεντρωτικές υπηρεσίες π.χ. Mail server για ολόκληρη τη χώρα


Κατανομή

- Διαίρεσε ένα στοιχείο σε μικρότερα κομμάτια και μοίρασε σε όλο το σύστημα, π.χ. DNS –
    Domain Name Service
- Για την αντιστοίχηση ονομάτων σε διευθύνσεις δεν χρησιμοποιείται ένας μόνο server
- Ιεραρχικά δομημένο σαν δέντρο
- Χωρισμός σε (μη επικαλυπτόμενες) ζώνες– τομείς αρμοδιότητας (domains)
- Τα ονόματα σε κάθε ζώνη εξυπηρετούνται από ένα server π.χ., nl.vu.cs.flits

Ένα ΚΣ που επεκτείνεται γεωγραφικά συνήθως παρουσιάζει προβλήματα απόδοσης

```
Επεκτασιμότητα - Διαχείριση
```
Σε ένα ΚΣ έχουμε πολλούς και ανεξάρτητους διοικητικά τομείς

Υπάρχουν αντιθέσεις όσον αφορά στις πολιτικές που κάθε τομέας εφαρμόζει σε θέματα χρήσης
πόρων, πληρωμών, διαχείρισης, ασφάλειας, π.χ. στον ίδιο τομέα οι χρήστες εμπιστεύονται τον
administrator και τους υπόλοιπους χρήστες

Η εμπιστοσύνη όμως δεν είναι η ίδια και για άλλους τομείς

Ένας τομέας πρέπει να προστατεύεται από επιθέσεις από ένα άλλο τομέα

- read only file systems
- Χρήση ακριβών πόρων

**Ποιες οι διαφορετικές κατηγορίες (μοντέλα)** Middleware.

- Ενδιάμεσο λογισμικό που βασίζεται στα ΚΣ αρχείων (NFS, HDFS κλπ):
    Η επικοινωνία ανάγεται στην προσπέλαση των διαμοιραζόμενων αρχείων.
- Ενδιάμεσο λογισμικό που βασίζεται στις Κλήσεις Απομακρυσμένων Διαδικασιών (RPC):
    Μια διεργασία μπορεί να καλεί διαδικασία που υλοποιείται σε απομακρυσμένη μηχανή. Η
    καλούσα διεργασία δεν αντιλαμβάνεται ότι πραγματοποιήθηκε επικοινωνία μέσω δικτύου.
- Ενδιάμεσο λογισμικό που βασίζεται στα Κατανεμημένα Αντικείμενα (RMI, CORBA κ.α.):
    Κάθε αντικείμενο τοποθετείται σε μία μηχανή και οι μέθοδοι που υλοποιεί γίνονται
    διαθέσιμοι σε άλλες μηχανές. Όταν μια διεργασία καλεί μια μέθοδο, στέλνεται μήνυμα στο
    αντικείμενο το οποίο εκτελεί τη μέθοδο και στέλνει πίσω το αποτέλεσμα.


```
Lecture 2
```
Καλό διάβασμα

**Τι είναι** peer-to-peer;

Κάθε κόμβος διαθέτει το ίδιο λογισμικό και επομένως συμπεριφέρεται ως πελάτης και ως
διακομιστής.

Ομότιμη δράση των κόμβων.

Οι κόμβοι επικοινωνούν απ’ευθείας και όχι μέσω ενός server.

Αξιοποίηση των ελεύθερων πόρων συστημάτων

- Δημιουργία περισσότερο κλιμακούμενων συστημάτων
- Δημιουργία συστημάτων με μεγαλύτερη διαθεσιμότητα
- Κατάργηση μονοπωλίων στην διάθεση της πληροφορίας
- Αυτο-οργάνωση αντί κεντρικής διαχείρισης

**Ποιες είναι οι κατηγορίες** ( **τύποι** ) **των** peer-to-peer **συστημάτων;**

- Υβριδικά Ομότιμα Συστήματα
- Αδόμητα Ομότιμα Συστήματα
- Ιεραρχικά Ομότιμα Συστήματα
- Δομημένα Ομότιμα Συστήματα

**Υβριδικά Ομότιμα Συστήματα** (Hybrid P2P systems)

Υπάρχει ένας κεντρικός διακομιστής

Διαμοιρασμός αρχείων: Αν ένας κόμβος διαθέτει ένα αρχείο, οι άλλοι μπορούν να το αναζητήσουν
στον κεντρικό διακομιστή και να το κατεβάσουν από τη μηχανή όπου βρίσκεται (πχ Napster)

Πλεονεκτήματα

Διαμερισμός πόρων

- αποθηκευτικών, αφού οι χρήστες του συστήματος αποθηκεύουν τα αρχεία, όχι ο
    διακομιστής
- υπολογιστικών, αφού οι χρήστες του συστήματος εκτελούν τον υπολογισμό όχι ο
    διακομιστής
- επικοινωνίας, αφού το κατέβασμα αρχείων γίνεται μεταξύ των χρηστών χωρίς να
    παρεμβάλλεται ο διακομιστής
- εισαγωγής στοιχείων αφού οι χρήστες του συστήματος
    o εισάγουν τα δεδομένα στο σύστημα
    o οι χρήστες του συστήματος τα κατηγοριοποιούν

Η αποκέντρωση επιτρέπει τη δημιουργία εφαρμογών παγκόσμιας κλίμακας με μικρό κόστος!

Μειονεκτήματα: Central Point of Failure


**Αδόμητα Ομότιμα Συστήματα (Unstructured ή Pure** P2P systems)

Δεν υπάρχει κεντρικός εξυπηρετητής (Gnutella)

Χρήση κατακλυσμού μηνυμάτων (message flooding) για τον εντοπισμό πόρων (resource
discovery)

**Ιεραρχικά Ομότιμα Συστήματα** (Hierarchical P2P Systems)

Συνδυασμός υβριδικών και αδόμητων συστημάτων (π.χ. Kazaa)

Εντοπισμός Πόρων

- Η έννοια του superpeer / supernode
- Κάθε supernode αποθηκεύει καταλόγους όπως οι servers του Napster
- Οι supernodes αλλάζουν
- Οποιοσδήποτε κόμβος μπορεί να γίνει (και να παραμείνει) supernode αρκεί να έχει καλή
    φήμη (reputation – π.χ. με βάση τη διάρκεια που ο χρήστης είναι συνδεδεμένος, τον αριθμό
    uploads κ.α. πιο πολύπλοκα)
- Ένας κόμβος αναζητά πάντα μέσω του πιο κοντινού του supernode

BitTorrent - Ξεχωριστή περίπτωση (βλέπε διαφάνειες)

**Δομημένα Ομότιμα Συστήματα** (Structured P2P Systems)

(π.χ Chord, Pastry, Tapestry κ.α.)

Σκοπός: Γρήγορος εντοπισμός πόρων χωρίς τη χρήση κεντρικού διακομιστή και ανταλλάσσοντας
λίγα μηνύματα

Κοινά χαρακτηριστικά των δομημένων ομότιμων συστημάτων

- κάθε κόμβος διατηρεί ένα μικρό τμήμα του καθολικού ευρετηρίου (πίνακας δρομολόγησης)
- οι αναζητήσεις γίνονται με προώθηση μηνυμάτων προς τη «σωστή» κατεύθυνση

```
Πίνακας δρομολόγησης για εντοπισμό πόρου και επικοινωνία μεταξύ peer-to-peer
```
```
και
```
```
Πως οργανώνονται με hash οι κόμβοι ανάλογα το νούμερο τους σε ένα σύνολο αριθμών.
```
```
Όλα από σελίδα 7 4 – 91 βήμα βήμα
```

```
Lecture 3
```
Να μην δώσουμε σημασία στο DCE RPC.

**Τι είναι το** middleware **σαν έννοια και πως θα το κατατάσαμε μέσα στο μοντέλο** OSI.

Προκειμένου να υποστηριχτούν διαφορετικά είδη υπολογιστών και δικτύων και παράλληλα να
προσφέρουν μια ομοιόμορφη εικόνα στους τελικούς χρήστες, τα ΚΣ συνήθως αποτελούνται από
ένα επίπεδο λογισμικού, το middleware. Το λογισμικό αυτό τοποθετείται λογικά μεταξύ ενός
υψηλότερου επιπέδου που αποτελείται από τους χρήστες και τις εφαρμογές και ενός χαμηλότερου
επιπέδου που αποτελείται από λειτουργικά συστήματα. Θα το κατατάσαμε ενδιάμεσα από το
transport και το application.

**Περιγράψτε το μοντέλο** client-server.

- Ένα σύστημα client-server είναι ένα σύστημα στο οποίο το δίκτυο ενώνει διάφορους
    υπολογιστικούς πόρους, ώστε οι clients (front end) να μπορούν να ζητούν υπηρεσίες από
    έναν server (back end) που προσφέρει πληροφορίες ή πρόσθετη υπολογιστική ισχύ.
- Το client-server μοντέλο βασίζεται, συνήθως, σε ένα απλό πρωτόκολλο αίτησης/απάντησης
    (request/reply).
    o Ο πελάτης στέλνει ένα μήνυμα (αίτηση) ζητώντας από τον εξυπηρετητή κάποια
       υπηρεσία.
    o Ο εξυπηρετητής ενεργοποιείται άμεσα ή προσθέτει την αίτηση σε μια ουρά. Τελικά
       αποκρίνεται εκτελώντας μια σειρά από ενέργειες και επιστρέφει μια απάντηση, συνήθως
       με τα δεδομένα που ζητήθηκαν ή ένα μήνυμα λάθους.

**Ποιες οι κατηγορίες (μοντέλα) ενδιάμεσου λογισμικού και ποια τα χαρακτηριστικά της
καθεμίας**.

- Ενδιάμεσο λογισμικό που βασίζεται στα ΚΣ αρχείων (NFS, HDFS κλπ):
    Η επικοινωνία ανάγεται στην προσπέλαση των διαμοιραζόμενων αρχείων.
- Ενδιάμεσο λογισμικό που βασίζεται στις Κλήσεις Απομακρυσμένων Διαδικασιών (RPC):
    Μια διεργασία μπορεί να καλεί διαδικασία που υλοποιείται σε απομακρυσμένη μηχανή. Η
    καλούσα διεργασία δεν αντιλαμβάνεται ότι πραγματοποιήθηκε επικοινωνία μέσω δικτύου.
- Ενδιάμεσο λογισμικό που βασίζεται στα Κατανεμημένα Αντικείμενα (RMI, CORBA κ.α.):
    Κάθε αντικείμενο τοποθετείται σε μία μηχανή και οι μέθοδοι που υλοποιεί γίνονται
    διαθέσιμοι σε άλλες μηχανές. Όταν μια διεργασία καλεί μια μέθοδο, στέλνεται μήνυμα στο
    αντικείμενο το οποίο εκτελεί τη μέθοδο και στέλνει πίσω το αποτέλεσμα.

**Ποιες υπηρεσίες υποστηρίζουν τα πρωτόκολλα ενδιάμεσου λογισμικού;**

Τα πρωτόκολλα επικοινωνίας του ενδιάμεσου λογισμικού υποστηρίζουν ποικιλία υπηρεσιών
ενδιάμεσου λογισμικού:

- Πρωτόκολλα πιστοποίησης ταυτότητας (Authentication)
- Πρωτόκολλα εξουσιοδότησης πρόσβασης (Authorization) σε πιστοποιημένους χρήστες
- Πρωτόκολλα κατανεμημένης δέσμευσης (Distributed commit) ή ατομικότητας
- Πρωτόκολλα κατανεμημένου κλειδώματος (προστασία πόρων από ταυτόχρονη πρόσβαση)


Τα πρωτόκολλα επικοινωνίας του ενδιάμεσου λογισμικού υποστηρίζουν υπηρεσίες επικοινωνίας
υψηλού επιπέδου:

- κλήση απομακρυσμένων διαδικασιών
- κλήση απομακρυσμένων αντικειμένων

**Ποια τα βήματα για επικοινωνία με χρήση απομακρυσμένων διαδικασιών** ( **γενικά)**.

```
( Προσοχή- βήματα RPC πιο κάτω!)
```
- Όταν μία διαδικασία στη μηχανή Α καλέσει μία διαδικασία στη μηχανή Β, η εκτέλεση της
    διεργασίας στην Α αναστέλλεται και η εκτέλεση της καλούμενης διαδικασίας συνεχίζεται στη
    μηχανή Β
- Πληροφορίες δίνονται από την καλούσα και την καλούμενη με τη μορφή παραμέτρων
- Απόκρυψη της πραγματικής επικοινωνίας - Δεν λαμβάνεται γνώση της μεταβίβασης των
    μηνυμάτων και της λειτουργίας εισόδου/εξόδου

**Ποια τα βήματα για απομακρυσμένη κλήση** RPC.

- Η διαδικασία του πελάτη καλεί το στέλεχος πελάτη
- Το στέλεχος πελάτη σχηματίζει ένα μήνυμα και καλεί το τοπικό ΛΣ που στέλνει το μήνυμα
    στο απομακρυσμένο ΛΣ
- Το απομακρυσμένο ΛΣ παραδίδει το μήνυμα στο στέλεχος διακομιστή
- Το στέλεχος διακομιστή ξεπακετάρει τις παραμέτρους από το μήνυμα και καλεί τον
    διακομιστή για να το εκτελέσει
- Ο διακομιστής επιστρέφει τα αποτελέσματα στο στέλεχος του διακομιστή, το οποίο
    σχηματίζει μήνυμα με τα αποτελέσματα και καλεί το τοπικό ΛΣ
- Το ΛΣ του διακομιστή στέλνει το μήνυμα στο ΛΣ του πελάτη
- Το ΛΣ του πελάτη παραδίδει το μήνυμα στο στέλεχος πελάτη που ξεπακετάρει και
    επιστρέφει τα αποτελέσματα στον πελάτη

**Πως επιτυγχάνεται η διαφάνεια του μηχανισμού** RPC

Η διαφάνεια της λειτουργίας του μηχανισμού RPC επιτυγχάνεται με την χρήση **στελεχών** -
**υποκατάστατων** (stubs) client & server της διαδικασίας που καλείται.

```
Υλοποίηση της απομακρυσμένης κλήσης με 2 τοπικές κλήσεις
```
- Κλήση στελέχους πελάτη τοπικά από πελάτη
- Κλήση διαδικασίας τοπικά από το στέλεχος διακομιστή

```
Στέλεχος πελάτη (client stub)
```
- Ίδια κλητική ακολουθία με διαδικασία
- Εκδοχή της απομακρυσμένης διαδικασίας στον πελάτη
    Στέλεχος διακομιστή (server stub)
- Εκτελεί την κλήση της διαδικασίας
- Μετατρέπει τις εισερχόμενες κλήσεις σε τοπικές κλήσεις


**Υποστηρίζονται οι παράμετροι στην** RPC **φιλοσοφία κι αν ναι ποιες οι δυνατότητες** ;

Ναι, πληροφορίες δίνονται από την καλούσα και την καλούμενη διεργασία με τη μορφή
παραμέτρων.

```
Μεταβίβαση παραμέτρων κατ’αξία
```
1. Ο πελάτης καλεί την procedure.
2. Το στέλεχος πελάτη ‘χτίζει’ το μήνυμα.
3. Το μήνυμα περνάει από το δίκτυο με προορισμό τον server.
4. Το ΛΣ του server περνάει το μήνυμα στο στέλεχος διακομιστή.
5. Το στέλεχος διακομιστή ‘ξεπακετάρει ́ το μήνυμα.
6. Το στέλεχος διακομιστή καλεί την απαραίτητη συνάρτηση.

```
Μεταβίβαση παραμέτρων με αντιγραφή-επαναφορά
```
1. Ο πίνακας αντιγράφεται μέσα στο μήνυμα και στέλνεται στο διακομιστή.
2. Το στέλεχος διακομιστή καλεί το διακομιστή με παράμετρο ένα δείκτη σε αυτόν τον πίνακα
    (ο δείκτης θα έχει διαφορετική τιμή από τον αρχικό). Οι αλλαγές που κάνει ο διακομιστής,
    επηρεάζουν τον χώρο προσωρινής αποθήκευσης του μηνύματος στο στέλεχος του
    διακομιστή.
3. Όταν ο διακομιστής τελειώσει, το αρχικό μήνυμα στέλνεται στο στέλεχος πελάτη.
4. Το στέλεχος πελάτη αντιγράφει τον πίνακα πίσω στον πελάτη.

Βελτιστοποίηση: η μία αντιγραφή μπορεί να παραλειφθεί.

- Αν ο πίνακας είναι είσοδος για το διακομιστή δε χρειάζεται να σταλεί στο στέλεχος πελάτη.
- Αν είναι έξοδος δε χρειάζεται να σταλεί αρχικά στο διακομιστή.

Είναι **δυνατός** ο χειρισμός δεικτών σε πίνακες με γνωστό μέγεθος.

**Δεν είναι δυνατός** ο χειρισμός δεικτών σε μια οποιαδήποτε δομή δεδομένων. Για το χειρισμό
τέτοιων δεικτών επιχειρούνται λύσεις όπως: μεταβιβάζεται ο δείκτης στο στέλεχος διακομιστή και
στέλνεται πίσω στον πελάτη αίτηση για την αποστολή των αναφερόμενων δεδομένων.

**Ποια τα βασικά σε σύγχρονη – ασύγχρονη** RPC ( **καθυστερημένη σύγχρονη** RPC **–
μονόδρομη** RPC).

Στη σύγχρονη (συμβατική RPC) επικοινωνία RPC ο πελάτης μπλοκάρεται μέχρι να επιστραφεί
απάντηση.

Στην ασύγχρονη RPC ο πελάτης συνεχίζει αμέσως μετά την παραλαβή επιβεβαίωσης αποδοχής
της αίτησης από τον διακομιστή. Αν πρόκειται να επιστραφεί απάντηση αλλά ο πελάτης δεν είναι
διατεθειμένος να περιμένει:

Καθυστερημένη σύγχρονη RPC: η επικοινωνία επιτυγχάνεται με δύο ασύγχρονες RPCs.

Μονόδρομη RPC: ο πελάτης δεν περιμένει για επιβεβαίωση της αποδοχής της αίτησης από τον
διακομιστή. (Σχηματικά σελίδα 32)

Πρόβλημα αξιοπιστίας: ο πελάτης δε γνωρίζει με βεβαιότητα ότι το μήνυμά του έχει παραληφθεί
και η αίτηση θα διεκπεραιωθεί.


```
Lecture 4
```
**Ποια τα βασικά του** SUN RPC.

- Μία συλλογή απομακρυσμένων διαδικασιών αποτελεί ένα πρόγραμμα.
- Κάθε πρόγραμμα έχει ένα μοναδικό αριθμό (στον server) και έναν αριθμό έκδοσης (version
    number)
- Κάθε διαδικασία του προγράμματος έχει και αυτή έναν αριθμό (μοναδικό εντός
    προγράμματος)
- Μία διαδικασία σε ένα server καθορίζεται μοναδικά από:
    {program-number, version-number, procedure-number}
- Χρησιμοποιεί ένα binder (rpcbind deamon) σε κάθε server μηχάνημα
    o Με rpcinfo παίρνουμε κατάλογο όλων των registered προγραμμάτων από τον binder
- Ο binder είναι και αυτός ένα RPC πρόγραμμα (ID 100000, version=2). Ο binder ξεκινά πριν
    από όλους τους servers
- Κάθε RPC server στην εκκίνησή του συνδέεται με ένα socket και κάνει registration στον
    rpcbind (μέσω ενός RPC call) τα
       ➢ program number, version number,
       ➢ και socket (protocol, port number)
    o Ο RPC client στέλνει τα program number, version number, και protocol στον binder και
       μαθαίνει το port number του server
    o Κατόπιν ο client στέλνει RPC call message στο socket του server, ο οποίος εκτελεί την
       κατάλληλη διαδικασία

**Να περιγραφεί με λόγια πως δουλεύει το παρακάτω σχήμα** :

![[sync_n_async2.png]]


Απαιτείται η περιγραφή του RPC interface μιας εφαρμογής (ποιες απομακρυσμένες διαδικασίες
προσφέρονται και με τι ορίσματα, όνομα προγράμματος και version number κλπ).

Γράφεται από τον προγραμματιστή σε ένα IDL (interface definition language) που ονομάζεται
RPCL και αποτελεί επέκταση του XDR.

Διατίθεται compiler (rpcgen) για αυτόματη δημιουργία stub routines, header file, xdr filter file.

Ο προγραμματιστής γράφει επίσης την απομακρυσμένη διαδικασία, και το πρόγραμμα client

Παράδειγμα μετατροπής Τοπικής Διαδικασίας σε Απομακρυσμένη

Έστω το πρόγραμμα (printmsg.c), το οποίο τυπώνει ένα μήνυμα στην κονσόλα n φορές, και τρέχει
σε έναν Η/Y.

Η μετατροπή του σε πρόγραμμα που τυπώνει σε απομακρυσμένους Η/Υ, μέσω RPC απαιτεί την
εξής διαδικασία:

```
o γράφουμε ένα protocol specification σε γλώσσα RPC (msg.x) το οποίο περιγράφει την
απομακρυσμένη έκδοση του `printmsg()’
o εκτελούμε rpcgen msg.x και δημιουργούνται αυτόματα τα αρχεία:
▪ msg.h // include file
▪ msg_xdr.c //XDR filters
▪ msg_clnt.c // client stub
▪ msg_svc.c //server stub
```
Στη συνέχεια γράφουμε το client πρόγραμμα rprintmsg.c και το απομακρυσμένο πρόγραμμα
msg_proc.c

Κατόπιν δημιουργούμε το εκτελέσιμο αρχείο του server:

```
o gcc msg_proc.c msg_svc.c msg_xdr.c – o msg_server
```
Και το εκτελέσιμο του client:

```
o gcc rprintmsg.c msg_clnt.c msg_xdr.c – o rprintmsg
```
Αν ο msg_server εκτελείται στη μηχανή hostx.yyy.gr, μπορούμε να τυπώσουμε 5 φορές το μήνυμα
«!?» από απομακρυσμένο Η/Υ με την εντολή rprintmsg hostx.yyy.gr «!?» 5

**Τι είναι κατανεμημένο αντικείμενο και ποια τα ‘είδη του’** ;

Ένα αντικείμενο του οποίου οι μέθοδοι μπορούν να κληθούν εξ’ αποστάσεως. Tο αντικείμενο και η
διασύνδεσή του βρίσκεται σε ένα μηχάνημα αλλά η διασύνδεσή του μπορεί να γίνεται διαθέσιμη σε
απομακρυσμένες διεργασίες.

RMI: Αν ένας πελάτης «συνδυαστεί με ένα αντικείμενο» τότε μπορεί να καλέσει τις μεθόδους του
αντικειμένου μέσω του εξουσιοδότη ή διαμεσολαβητή.

Αντικείμενο Εξουσιοδότης ή Διαμεσολαβητής (proxy): μια υλοποίηση της διασύνδεσης ενός
αντικειμένου που φορτώνεται στο χώρο διευθύνσεων του πελάτη όταν ο πελάτης συνδυάζεται
(bind) με το αντικείμενο.Ο διαμεσολαβητής παρατάσσει αιτήσεις κλήσεων μεθόδων σε μηνύματα
και αποπαρατάσσει τις απαντήσεις.

Αντικείμενο Σκελετός (skeleton): στέλεχος διακομιστή που παραλαμβάνει τις αιτήσεις, τις
αποπαρατάσσει σε κλήσεις μεθόδων της διασύνδεσης που βρίσκεται στον διακομιστή και
παρατάσσει και προωθεί τις απαντήσεις στον διαμεσολαβητή.


```
➢ Ένα κατανεμημένο αντικείμενο δημιουργείται από την κλάση που το ορίζει με την πρώτη
αναφορά – ίδιος τρόπος με τα ́απλά ́, τοπικά, αντικείμενα.
➢ Η μονάδα που δημιούργησε το αντικείμενο είναι υπεύθυνη για την διαχείριση του
➢ Κάθε απομακρυσμένη διεργασία που επιθυμεί να χρησιμοποιήσει το αντικείμενο, πρέπει να
επικοινωνήσει με την μονάδα που το δημιούργησε(διαχειριστή)
» Η μονάδα διαχειριστής κρατάει δείκτες προς τις διεργασίες που έχουν ζητήσει
πρόσβαση στο κατανεμημένο αντικείμενο
» Ορισμένοι μηχανισμοί περισυλλογής άχρηστων αντικειμένων(Garbage Collection)
ακολουθούν την ίδια τακτική
➢ Όταν ένα αντικείμενο δεν έχει κανένα δείκτη προς κάποια διεργασία θεωρείται άχρηστο και
περισυλλέγεται
➢ Μία διεργασία εξυπηρέτης δημιουργεί το πρώτο αντικείμενο σύμφωνα με την κλάση που το
ορίζει
➢ Καταχωρεί τα στοιχεία του αντικειμένου (και της κλάσης που το ορίζει) σε μια υπηρεσία
καταλόγου σύμφωνα με ένα όνομα
➢ Όταν μια διεργασία πελάτης θελήσει να χρησιμοποιήσει το κατανεμημένο αντικείμενο, το
αναζητάω μέσω της υπηρεσίας καταλόγου με βάση το όνομα
➢ Η αναζήτηση επιστρέφει πληροφορίες για την τοποθεσία της κλάσης του αντικειμένου, την
ύπαρξη ή όχι του αντικειμένου
➢ Ένα αντικείμενο μπορεί να μην χρησιμοποιηθεί για μεγάλο χρονικό διάστημα
» Για λόγους εξοικονόμησης πόρων, το σύστημα απομακρύνει τα ανενεργά αντικείμενα
σε δευτερεύουσα μονάδα αποθήκευσης
➢ Όταν μια διεργασία χρησιμοποιήσει τον τοπικό εξουσιοδότη (proxy) το σύστημα επαναφέρει
το αντικείμενο στην πρωτεύουσα μονάδα αποθήκευσης (επαναφορά)
➢ Η απομάκρυνση και επαναφορά αντιστοιχεί στην λογική διαχείρισης σελίδων εικονική
μνήμης
➢ Το σύστημα (εξυπηρέτης) που δημιούργησε το κατανεμημένο αντικείμενο Α, διατηρεί ένα
διάνυσμα Α.ν
➢ Όταν μια διεργασία p (πελάτης) δημιουργήσει έναν τοπικό εξουσιοδότη (proxy) για το
κατανεμημένο αντικείμενο
» Το σύστημα εξυπηρέτης προσθέτει την p στο Α.ν
➢ Όταν μια διεργασία p (πελάτης) περισυλλέξει τον τοπικό εξουσιοδότη (proxy) – δεν υπάρχει
καμία (τοπική) αναφορά
» Το σύστημα εξυπηρέτης αφαιρεί την p από το Α.ν
```
Αν ένα αντικείμενο έχει κενό διάνυσμα για ορισμένο χρονικό διάστημα – το σύστημα θεωρεί ότι δε
χρησιμοποιείται: το αντικείμενο περισυλλέγεται.

**Ποιόν ρόλο παίζουν οι συναρτήσεις τύπου** stub / skeleton **παρόμοιο με το** RPC **και ποια
είναι τα βήματα όπως περιγράφονται**.

Για κάθε αντικείμενο υπάρχει ένα αντικείμενο σκελετού.

Για κάθε απομακρυσμένη αναφορά υπάρχει ένα αντικείμενο εξουσιοδότης (proxy object).

Το αντικείμενο εξουσιοδότης αντιστοιχεί στο client stub.

Το αντικείμενο σκελετού αντιστοιχεί στο server stub.

Η χρήση των μεθόδων του κατανεμειμένου αντικειμένου γίνεται μέσω του RM runtime.


Λειτουργία του stub

Κατά την επίκληση μίας μεθόδου του stub, γίνονται τα παρακάτω:

- Εκκίνηση μίας σύνδεσης με την απομακρυσμένη JVM που περιέχει το απομακρυσμένο
    αντικείμενο.
- Εγγραφή και μετάδοση των παραμέτρων στην απομακρυσμένη JVM.
- Αναμονή του αποτελέσματος της απομακρυσμένης επίκλησης της μεθόδου.
- Ανάγνωση της απάντησης ή της εξαίρεσης που επιστρέφεται από την απομακρυσμένη
    επίκληση.
- Επιστροφή της τιμής στον καλούντα.

Λειτουργία του skeleton

Όταν το skeleton λαμβάνει ένα μήνυμα κάνει τα εξής:

- Διαβάζει τις παραμέτρους για την απομακρυσμένη μέθοδο
- Κάνει επίκληση της μεθόδου στο πραγματικό απομακρυσμένο αντικείμενο
- Γράφει και μεταδίδει το αποτέλεσμα (τιμή ή εξαίρεση) στον πελάτη.

**Τι γίνεται με παραμέτρους στην αντικειμενοστρεφή προσέγγιση;**

Όταν καλείται μια μέθοδος με μια αναφορά αντικειμένου ως παράμετρο, η αναφορά αυτή
αντιγράφεται και μεταβιβάζεται ως τιμή παραμέτρου μόνο όταν «δείχνει» σε απομακρυσμένο
αντικείμενο (το αντικείμενο μεταβιβάζεται κατ’ αναφορά).

Όταν η αναφορά παραπέμπει σε τοπικό αντικείμενο, τότε αυτό αντιγράφεται ολόκληρο και
μεταβιβάζεται με την κλήση (το αντικείμενο μεταβιβάζεται κατ’ αξία)

**Περιγράψτε το γενικότερο μοντέλο** RMI **και με ποιο τρόπο υλοποιείται και πως υποστηρίζει
την αντικειμενοστρεφή διαδικασία** middleware.

Κατά την εκτέλεση μιας απομακρυσμένης διαδικασίας, το java.rmi κωδικοποιεί τις παραμέτρους
κλήσης και τις στέλνει στο server. Αυτός τις αποκωδικοποιεί και καλεί τη μέθοδο. Κωδικοποιεί τα
αποτελέσματα και τα στέλνει πίσω στον client. To java.rmi στον client αποκωδικοποιεί την
απάντηση.

Εύρεση Απομακρυσμένων Αντικειμένων – Χρήση του Registry

Το RMI προσφέρει ένα απλό σχήμα ονομασίας, το οποίο δίνει ένα όνομα σε ένα απομακρυσμένο
αντικείμενο όταν τρέχει για πρώτη φορά.

Στη συνέχεια καταχωρείται στο RMI registry με μια διαδικασία εγγραφής.

Το registry συνδέει το όνομα του αντικειμένου (όχι το όνομα της κλάσης) και το ίδιο το αντικείμενο.

Στη Java, όταν ένα απομακρυσμένο αντικείμενο εγγράφεται στο registry μίας συγκεκριμένης
μηχανής, συνδέεται με ένα αντικείμενο ονοματοδοσίας.

Αν ένα πελάτης θέλει να χρησιμοποιήσει ένα αντικείμενο, το οποίο βρίσκεται σε έναν
απομακρυσμένο κόμβο A:


- κάνει μία αναζήτηση στο Registry του Α.
- χρησιμοποιεί το αποτέλεσμα της αναζήτησης για να συνδεθεί με το απομακρυσμένο
    αντικείμενο, και να παρεμβάλλει τις μεθόδους του.

Ο server δημιουργεί ένα απομακρυσμένο αντικείμενο και το καταχωρεί στο registry

O client το ζητά από το registry

To registry επιστρέφει μια απομακρυσμένη αναφορά (και δημιουργείται το stub)

O client καλεί τη μέθοδο του stub

To stub μιλά με το skeleton

To skeleton καλεί την μέθοδο του απομακρυσμένου αντικειμένου

**Τι είναι το** blocking **απομακρυσμένων αντικειμένων;**

H Java επιτρέπει την κατασκευή ενός αντικειμένου ως ελεγκτή (monitor) με τη δήλωση μιας
μεθόδου ως συγχρονισμένης (synchronized). Αν δύο εργασίες καλέσουν ταυτόχρονα μια
συγχρονισμένη μέθοδο, μόνο η μία μπορεί να προχωρήσει ενώ η άλλη θα μπλοκαριστεί.

Προσέγγιση 1: Μπλοκάρονται οι πελάτες στο στέλεχος πελάτη που υλοποιεί τη διασύνδεση
αντικειμένου.

- Η λύση αυτή απαιτεί το συγχρονισμό διαφορετικών πελατών σε διαφορετικά μηχανήματα.
- Ο κατανεμημένος συγχρονισμός είναι αρκετά πολύπλοκος.

Προσέγγιση 2: Το μπλοκάρισμα επιτρέπεται μόνο στο διακομιστή.

- Προκύπτουν προβλήματα σε περίπτωση που ένας πελάτης καταρρεύσει ενώ ο διακομιστής
    χειρίζεται την κλήση του.

Το μπλοκάρισμα απομακρυσμένων αντικειμένων περιορίζεται μόνο στους διαμεσολαβητές.

Τα απομακρυσμένα αντικείμενα δε προστατεύονται από την ταυτόχρονη προσπέλαση από
διεργασίες που εκτελούνται σε διαφορετικούς διαμεσολαβητές με τη χρήση συγχρονισμένων
μεθόδων.

Χρησιμοποιούνται τεχνικές ρητών κατανεμημένων κλειδωμάτων.

**Περιγράψτε τη μηνυματοστρεφή επικοινωνία.**

**Τι γνωρίζετε για παροδική και διατηρούμενη επικοινωνία.**

**Τι γνωρίζετε για σύγχρονη και ασύγχρονη επικοινωνία**.

Διατηρούμενη Επικοινωνία - Persistent Communication:

Μόλις στείλει το μήνυμα, ο αποστολέας μπορεί να σταματήσει. Ο παραλήπτης δεν χρειάζεται να
είναι σε λειτουργία - το σύστημα αποθηκεύει το μήνυμα μέχρι να παραδοθεί.

- Οι εφαρμογές σχεδιάζονται έτσι ώστε να μπορούν να χειρίζονται μακρόχρονες
    καθυστερήσεις μεταξύ αποστολής αίτησης και λήψης απάντησης.
- Συνεπώς, απλούστερες και πιο αργές λύσεις για τη συγκάλυψη αστοχιών και την ανάκαμψη
    είναι αρκετές.

Παροδική Επικοινωνία - Transient Commuication:


Το μήνυμα αποθηκεύεται μόνο για όσο διάστημα ο αποστολέας και ο παραλήπτης είναι σε
λειτουργία. Εάν προκύψουν προβλήματα, το μήνυμα απορρίπτεται.

- Σε δίκτυα μεγάλης κλίμακας και ευρείας γεωγραφικής διασποράς η πρόσβαση μπορεί να
    είναι προβληματική λόγω αστοχιών
- Όταν παρουσιάζεται αστοχία θα πρέπει να συγκαλύπτεται αμέσως και να ξεκινά διαδικασία
    ανάκαμψης.

Ασύγχρονη Επικοινωνία :

Ο αποστολέας συνεχίζει με άλλες εργασίες αμέσως μετά την αποστολή του μηνύματος στον
παραλήπτη.

Σύγχρονη Επικοινωνία :

Ο αποστολέας περιμένει απάντηση από τον παραλήπτη πριν κάνει οποιαδήποτε
άλλη εργασία. (Αυτό τείνει να είναι το default μοντέλο για τις τεχνολογίες RPC /RMI).



```
Lecture 6
```
Έμφαση στα βήματα των αλγόριθμων και στην πολυπλοκότητα τους

**Φυσικά ρολόγια**

Χρονόμετρο υπολογιστή: Κρύσταλλος χαλαζία (highfrequency oscillator), μετρητής και
καταχωρητής διατήρησης (holding register)

- Κάθε ταλάντωση του κρυστάλλου μειώνει το μετρητή κατά ένα. Όταν ο μετρητής φθάσει στο
    0, προκαλείται μία διακοπή και ο μετρητής επαναφορτώνεται από τον καταχωρητή
    διατήρησης. Κάθε διακοπή ονομάζεται χτύπος ρολογιού.
- Ένα χρονόμετρο μπορεί να προγραμματιστεί ώστε να προκαλεί διακοπή 60 (ή/και
    περισσότερες) φορές το δευτερόλεπτο.
- Σε ένα δίκτυο υπολογιστών, οι συχνότητες ταλάντωσης των κρυστάλλων των ρολογιών
    μπορεί να διαφέρουν (απόκλιση ρολογιού).

Ατομικό ρολόι (1948): το δευτερόλεπτο ορίζεται ως το διάστημα που χρειάζεται το άτομο του
καισίου 133 για να πραγματοποιήσει 9.192.631.770 μεταπτώσεις.

TAI – International Atomic Time: 50 εργαστήρια στον κόσμο διαθέτουν ρολόγια καισίου και
αναφέρουν το πλήθος των χτύπων των ρολογιών τους στο Διεθνές Γραφείο Ώρας το οποίο
υπολογίζει το μέσο όρο χτύπων για να παράγει την ΤΑΙ. Η ΤΑΙ δεν είναι απόλυτα συντονισμένη με
την ηλιακή ώρα. Κάθε φορά που η διαφορά ανάμεσα στην ΤΑΙ και την ηλιακή ώρα φτάνει τα 800
msec το Διεθνές Γραφείο Ώρας προσθέτει συμπληρωματικά δευτερόλεπτα (UTC – Universal
Coordinated Time).

**Αλγόριθμος** Christian

Περιοδικά (κάθε δ/2ρ δευτερόλεπτα)

1. Κάθε μηχανή (αποστολέας) ρωτάει τον διακομιστή ώρας για την τρέχουσα ώρα
2. Ο διακομιστής στέλνει την τρέχουσα ώρα CUTC
3. Ο αποστολέας ρυθμίζει το ρολόι του σύμφωνα με την CUTC

Είναι κατάλληλος όταν μία μηχανή διαθέτει δέκτη WWV (διακομιστής ώρας) και θέλουμε όλες οι
άλλες μηχανές να είναι συγχρονισμένες με αυτήν (παρόμοια για δέκτη GPS).

- Χρησιμοποιεί time server για τον συγχρονισμό – είναι σχεδιασμένος κυρίως για LAN γιατί
    βασίζεται αυστηρά στην καλή εκτίμηση του round trip time.
- Ο χρόνος μετάδοσης μετ’ επιστροφής (Round Trip Time – RTT) εισάγει καθυστέρηση που
    πρέπει να εκτιμηθεί
- Εκτίμηση για την καθυστέρηση μιας διαδρομής - ο client μπορεί να θέσει το ρολόι του σε Τ+
    RTT/
- Αν μπορεί να εκτιμηθεί ο χρόνος επεξεργασίας της διακοπής στον server (Ι) το ρολόι
    μπορεί υπό
- προϋποθέσεις να τεθεί σε Τ+(RTT-Ι)/
- Στατιστική επεξεργασία (επαναλαμβανόμενες μετρήσεις,διόρθωση εκτιμήσεων)


**Αλγόριθμος** Barkeley

1. Αρχικά, ο time daemon ρωτά όλες τις άλλες μηχανές σχετικά με τις τιμές των ρολογιών
    τους.
2. Οι μηχανές απαντούν (offsets).
3. Ο time daemon υπαγορεύει σε όλους πώς να προσαρμόσουν το ρολόι τους, με βάση τη
    μέση τιμή που υπολόγισε.

Είναι κατάλληλος όταν καμία μηχανή δε διαθέτει δέκτη WWV/GPS

- Ο διακομιστής (δαίμονας ώρας) διενεργεί περιοδικούς ελέγχους σε κάθε μηχανή για να
    πληροφορηθεί την ώρα της.
- Βάσει των απαντήσεων, υπολογίζει μια μέση ώρα και δίνει εντολή σε όλες τις μηχανές να
    ρυθμίσουν τα ρολόγια τους σύμφωνα με την καινούργια ώρα

**Λογικά ρολόγια**

Ένας κατανεμημένος υπολογισμός περιγράφει την εκτέλεση ενός συνόλου ακολουθιακών
διεργασιών

Κάθε διεργασία συνίσταται στην εκτέλεση μιας ακολουθίας γεγονότων. Δύο είδη γεγονότων:

- Εσωτερικό γεγονός ή γεγονός υπολογισμού: προκαλεί αλλαγή της κατάστασης της
    διεργασίας (αλλαγή τιμών τοπικών μεταβλητών).
- Γεγονός επικοινωνίας με κάποια άλλη διεργασία: προκαλεί μετακίνηση ενός μηνύματος m
    από τον outbuf του αποστολέα στον inbuf του παραλήπτη μέσω των send(m) και
    receive(m).

Διάγραμμα χώρου-χρόνου: απεικόνιση ενός κατανεμημένου υπολογισμού μέσα στο χρόνο.

**Αλγόριθμος** Lamport **και ποιο είναι το μειονέκτημα του και τι χρησιμοποιείται για να το
πετύχει αυτό**.

Βασική Ιδέα: Αν το γεγονός A συμβαίνει πριν το B, τότε θα πρέπει: ο χρόνος LT (Logical Time) του
A να είναι μικρότερος από τον χρόνο LT (Logical Time) του B, ήτοι LT(A) < LT(B).

Συνήθως, έχει σημασία η συμφωνία όλων των διεργασιών ως προς τη σειρά με την οποία
λαμβάνουν χώρα τα διαφορετικά γεγονότα και όχι η συμφωνία τους για την ακριβή ώρα.

Κάθε διεργασία Pi διατηρεί μια τοπική μεταβλητή LTi η οποία καλείται λογικό ρολόι και αποθηκεύει
μη αρνητικούς ακέραιους και έχει αρχική τιμή 0.

1. Πριν από την εκτέλεση ενός γεγονότος η Pi εκτελεί LTi ← LTi + 1.
2. Όταν η διεργασία Pi στέλνει μήνυμα m στην Pj , θέτει την χρονοσφραγίδα ts(m) (timestamp) του
m ίση με LTi.
3. Όταν η διεργασία Pj λάβει το m προσαρμόζει το διάνυσμά της θέτοντας LTj ← max{LTj , ts (m)}

Στη συνέχεια η Pj εκτελεί το βήμα 1. (μαρκάροντας έτσι με LTj +1 το γεγονός παραλαβής)


Ο Αλγόριθμος του Lamport μας δίνει ένα τρόπο να αποδίδουμε την ώρα σε όλα τα συμβάντα ενός
κατανεμημένου συστήματος έτσι ώστε:

Αν το α συμβεί πριν από το β στην ίδια διεργασία τότε LT(α) < LT(β).

Αν τα α και β αντιπροσωπεύουν την αποστολή και τη λήψη ενός μηνύματος αντίστοιχα, τότε LT(α)
< LT(β).

Για όλα τα διαφορετικά συμβάντα LT(α) ≠ LT(β)

(αυτό μπορούμε να το πετύχουμε και για ταυτόχρονα συμβάντα)

(πως; προσθέτοντας ως επιπλέον ένδειξη ένα μοναδικό αναγνωριστικό της διεργασίας)

Το μειονέκτημα του είναι πως δεν διασφαλίζει και δεν περιγράφει την αιτιότητα. Για να το
αντιμετωπίσει χρησιμοποιεί διανυσματικές χρονοσφραγίδες.

**Διανυσματικά ρολόγια** - **Διανυσματικές χρονοσφραγίδες**.

Έχουν τη διαφορά ότι κάθε διεργασία πρέπει αντί να κρατάει ένα ρολόι μόνο το δικό της και να το
ενημερώνει, ένα διάνυσμα το οποίο να περιλαμβάνει τιμές ρολογιών λογικών και των υπολοίπων,
το οποίο το διαχέει κάθε φορά σε αυτούς που επικοινωνεί μέσω μηνύματος προκειμένου να τους
περάσει όχι μόνο τη δική της ένδειξη λογικού ρολογιού αλλά και τι ξέρει η ίδια για τα λογικά
ρολόγια των υπολοίπων μέχρι εκείνη τη χρονική στιγμή. Και κάπως έτσι μπορεί να διατηρηθεί η
αιτιότητα των γεγονότων πιο ντετερμινιστικά σε όλες τις περιπτώσεις απότι στον αλγόριθμο του
Lamport παρότι χρειάζεται περισσότερος χρόνος και χώρος.

**Τι είναι η διασφάλιση αιτιοκρατικής παράδοσης μηνυμάτων.**

Παράδειγμα: Ηλεκτρονικός πίνακας ανακοινώσεων του Internet

Έστω ότι η Vci [i] προσαυξάνεται μόνον όταν η Pi στέλνει κάποιο μήνυμα.

Όταν μία διεργασία Pi δημοσιεύει ένα άρθρο, το στέλνει μέσω πολυεκπομπής ως μήνυμα a με
χρονοσφραγίδα vt(a)= Vci

Έστω ότι η Pj στέλνει μια απόκριση στο άρθρο μέσω πολυεκπομπής ως μήνυμα r με
χρονοσφραγίδα vt(r)= VCj

Ισχύει ότι vt(r)[j] > vt(a)[j]

Τα μηνύματα a και r θα φθάσουν σε μια τρίτη διεργασία Pk αλλά δεν γνωρίζουμε με ποια σειρά.

Όταν η Pκ λάβει το r από την Pj θα εξετάσει την vt(r) και θα αναβάλλει την παράδοση έως ότου
ληφθούν όλα τα μηνύματα που προηγούνται αιτιακά του r, ήτοι έως ότου

1. vt(r)[j] = VCk[j] + 1
2. vt(r)[i] <= VCk[i] για κάθε i≠ j

Η πρώτη συνθήκη δηλώνει ότι το r είναι το επόμενο μήνυμα που παίρνει η Pκ από την Pj.

Η δεύτερη συνθήκη δηλώνει ότι η Pκ έχει δει όλα τα μηνύματα που είχε δει η Pj κατά την
αποστολή του r (επομένως έχει δει και το α).


```
Lecture 7
```
Έμφαση στα βήματα των αλγόριθμων και στην πολυπλοκότητα τους

**Αλγόριθμοι Εκλογής Αρχηγού**

Πρόβλημα: Επιλογή μίας μόνο διεργασίας αρχηγού/συντονιστή προκειμένου να εκτελέσει ένα
συγκεκριμένο καθήκον (εκτέλεση συγκεντρωτικών αλγορίθμων, επαναφορά από αδιέξοδο, να
αποτελέσει τη διεργασία-ρίζα στη δημιουργία ενός δένδρου επικάλυψης)

Δεν μπορεί αυθαίρετα μια διεργασία να αυτοανακηρυχθεί αρχηγός.

Θα πρέπει να προηγηθεί η εκτέλεση ενός αλγορίθμου εκλογής.

- Κάθε διεργασία πρέπει να αποφασίσει αν είναι ο αρχηγός ή όχι.
- Μία μόνο από τις διεργασίες θα πρέπει να αποφασίσει πως είναι ο αρχηγός.

Στόχος ενός αλγορίθμου εκλογής είναι να διασφαλίσει ότι όταν ξεκινήσει η διαδικασία εκλογής θα
καταλήξει με τη συμφωνία όλων των διεργασιών ως προς το ποιος είναι ο νέος αρχηγός.

Αρχικά

- ένα αυθαίρετο μη κενό σύνολο διεργασιών
- όλες οι διεργασίες ξεκινάνε από την ίδια κατάσταση (candidate)

Κάθε διεργασία εκτελεί τον ίδιο αλγόριθμο

Υπάρχουν δύο είδη τερματικών καταστάσεων για μια διεργασία:

η τερματική κατάσταση στην οποία η διεργασία έχει εκλεγεί αρχηγός (κατάσταση ισχύος ή
αρχηγού) και

η τερματική κατάσταση στην οποία η διεργασία δεν είναι ο αρχηγός (κατάσταση μη-ισχύος ή
χαμένου).

Επιτρεπτές εκτελέσεις:

Κάθε διεργασία τελικά εισέρχεται σε μια τερματική κατάσταση, ισχύος ή μη.

Μόνο μια διεργασία, ο αρχηγός, μπαίνει σε τερματική κατάσταση ισχύος.

**Αλγόριθμος Εκλογής Αρχηγού σε σύγχρονο δακτύλιο**

Έστω ένα κατανεμημένο σύστημα από n διεργασίες τοποθετημένες σε ένα δίκτυο δακτυλίου.

- Οι διεργασίες έχουν μοναδικές ταυτότητες (IDs).
- Οι διεργασίες δεν γνωρίζουν τις ταυτότητες των υπόλοιπων διεργασιών.

Κάθε διεργασία γνωρίζει μόνο ποιος είναι ο αριστερός (σύμφωνα με τους δείκτες του ρολογιού) και
ποιος ο δεξιός (αντίθετα με τους δείκτες του ρολογιού) της γείτονας.


Ενέργειες κάθε διεργασίας p:

- Αποστολή του ID της στα αριστερά.
- Όταν η p λάβει ένα ID (από δεξιά) κάνει τα εξής:
    ➢ αν είναι μεγαλύτερο από το δικό της, το προωθεί προς τα αριστερά
    ➢ αν είναι μικρότερο από το δικό της, το αγνοεί (και δεν το προωθεί)
    ➢ αν είναι ίσο με το δικό της, αποφασίζει πως αυτή είναι ο αρχηγός στο σύστημα και
       στέλνει ένα μήνυμα τερματισμού προς τα αριστερά
- Όταν η p λάβει μήνυμα τερματισμού, το προωθεί προς τα αριστερά και εισέρχεται σε
    τερματική κατάσταση μη ισχύος.

```
(Σχηματικά από σελίδα 13)
```
Ορθότητα αλγορίθμου: Θα εκλεγεί ως αρχηγός η διεργασία με το μεγαλύτερο ID. To μήνυμα με
αυτό το ID θα περάσει από όλες τις διεργασίες.

Χρονική πολυπλοκότητα: 2n = Ο(n)

Πολυπλοκότητα Επικοινωνίας: απαιτούνται O(n^2 ) μηνύματα

**Αλγόριθμος** Hirschberg-Singclair

Λειτουργεί σε k=0,...,log n -1 φάσεις.

Στην k-οστή φάση, ένας επεξεργαστής προσπαθεί να γίνει ο προσωρινός αρχηγός της 2k-γειτονιάς
του.

Μόνο οι επεξεργαστές που εκλέγονται αρχηγοί στην k-οστή φάση θα συνεχίσουν στην (k+1)-οστή
φάση.

Περιγραφή k-οστής Φάσης

- Κάθε διεργασία p, που εκλέχθηκε προσωρινός αρχηγός στην (k-1)-οστή φάση, στέλνει
    μηνύματα <probe> με το ID της σε όλους τουςκόμβους στην 2k-γειτονιά της. Κάθε μήνυμα
    <probe> περιέχει τον αριθμό της τρέχουσας φάσης k, και έναν μετρητή d (του μήκους του
    μονοπατιού που έχει διανυθεί).
- Μια διεργασία αγνοεί ένα μήνυμα τύπου <probe>, αν αυτό περιέχει ID που είναι μικρότερο
    από το δικό της.
- Όταν ένα μήνυμα τύπου <probe> φθάσει στην τελευταία διεργασία στη τρέχουσα γειτονιά,
    τότε αυτή η διεργασία στέλνει στην p ένα μήνυμα τύπου <reply>.
- Αν η p λάβει το <reply> και από τις δύο κατευθύνσεις, αποφασίζει πως είναι ο αρχηγός της
    2 k-γειτονιάς της στη φάση k.
- Η διεργασία που θα λάβει το δικό της μήνυμα τύπου <probe>,τερματίζει σε κατάσταση
    ισχύος (στέλνοντας μήνυμα τερματισμού στις υπόλοιπες).

Χρονική πολυπλοκότητα: Ο(n)

Πολυπλοκότητα Επικοινωνίας: απαιτούνται O(n log n) μηνύματα


```
Lecture 8
```
Έμφαση στα βήματα των αλγόριθμων και στην πολυπλοκότητα τους

**Εκλογή αρχηγού σε ισχυρά συνδεδεμένο γράφο** - **Αλγόριθμος εξαναγκασμού**

Μοντέλο κάθε διεργασία έχει ένα ID κάθε διεργασία γνωρίζει τα IDs όλων των υπολοίπων

αρχηγός εκλέγεται η διεργασία με τo μέγιστο ID μια διεργασία μπορεί να αποτυγχάνει και να
επανέρχεται οποτεδήποτε

Initiator μπορεί να είναι:

- μια διεργασία που διαπιστώνει ότι ο τρέχων αρχηγός δεν είναι ενεργός (π.χ. έχει πολλή
    ώρα να λάβει μήνυμα από αυτόν)
- μια διεργασία που επανέρχεται

Απλά ξέροντας όλοι όλους θέλουμε να εκλέξουμε αρχηγό αυτόν με τη μεγαλύτερη ταυτότητα. Αυτό
που κάνει ένας μόλις καταλάβει πως έπεσε ο αρχηγός είναι να στέλνει μηνύματα σε όλους όσους
έχουν μεγαλύτερο id από αυτόν. Ο παραλήπτης βλέπωντας πως έχει έρθει μήνυμα από μικρότερο
id εκινεί την ίδια διαδικασία εφόσον έχει μεγαλύτερους σε αριθμό και έτσι ο μεγαλύτερος στέλνει
μήνυμα πως παίρνει αυτός τη θέση του εκκινητή. Έτσι εξασφαλίζεται η πολύ γρήγορη απόφαση
ακόμα κι αν έχουμε faulty διεργασίες.

Μεγάλος αριθμός μηνυμάτων : O(n2)

**Αλγόριθμος** Flood Max

- Ο αλγόριθμος FloodMax έχει το προτέρημα της εύκολης υλοποίησης, και της καλής
    απόδοσης κάτω από ορισμένες συνθήκες χρονισμού του δικτύου (σύγχρονα συστήματα).
- Υποθέτει ότι οι διεργασίες έχουν μοναδικές ταυτότητες και οι διεργασίες γνωρίζουν μόνο
    την δικιά τους ταυτότητα.
- Υποθέτει ότι οι διεργασίες συνθέτουν ένα συνεκτικό δίκτυο n διεργασιών και m καναλιών
    (οποιασδήποτε τοπολογίας) και γνωρίζουν τη διάμετρο d του δικτύου.
- αλγόριθμος δεν απαιτεί την ταυτόχρονη εκτέλεση των βημάτων από όλες τις διεργασίες
    (ασύγχρονα συστήματα). Στην περίπτωση ασύγχρονης εκτέλεσης επιτυγχάνει συγκρίσιμα
    αποτελέσματα με εκείνα της σύγχρονης.
- Ο αλγόριθμος βασίζεται σε λειτουργίες σύγκρισης των ταυτοτήτων των διεργασιών. Η
    βασική ιδέα του αλγορίθμου βρίσκεται στην επιβίωση και προώθηση της μεγαλύτερης
    ταυτότητας που υπάρχει στο δίκτυο. Στο τέλος της εκτέλεσης κάθε διεργασία είναι σε θέση
    να γνωρίζει αυτή τη μέγιστη ταυτότητα.

Με τη μέθοδο της πλυμμήρας, καθένας όταν θέλει να εκλεγεί αρχηγός στέλνει την ταυτότητα του το
οποίο είναι το μέσο εκλογής μέσω των γειτόνων του σε όλο το δίκτυο. Κι έτσι ο καθένας
παίρνοντας τις ταυτότητες όλων(flood) να μπορεί με κάποιο τρόπο(optimal/σύγχρονο/ασύγχρονο)
να μπορούν να αποφασίσουν αν θα το προωθήσουν περαιτέρω (σύμφωνα με το id που έχουνε) ή
οχι.

Η χρονική πολυπλοκότητα είναι O(d)

H πολυπλοκότητα επικοινωνίας είναι O(dm)


**Αλγόριθμος** OptFloodMax

Bελτιώνει την απόδοση του FloodMax: Δεν πραγματοποιείται αποστολή μηνυμάτων στις γειτονικές
διεργασίες που αφορά ήδη γνωστή ταυτότητα.

- Στον πρώτο γύρο, οι διεργασίες εκπέμπουν την max_ID σε όλους τους γείτονες και θέτουν
    send = false.
- Στους επόμενους γύρους: Μόλις λάβουν μία ταυτότητα από κάποιον γείτονα, την
    συγκρίνουν με την max_ID. Αν είναι μεγαλύτερη, θέτουν την μεταβλητή στην νέα τιμή και
    send=true.
- Σε κάθε γύρο πραγματοποιούν αποστολή μηνύματος αν send = true.
- Μετά το τέλος της αποστολής, κάθε διεργασία θέτει send=false. Μετά από d γύρους, αν η
    μεταβλητή ισούται με την ταυτότητα της διεργασίας, η διεργασία μεταβαίνει στην κατάσταση
    ισχύος θέτοντας leader = true.

**Εκλογή Αρχηγού σε Δακτύλιο – Αλγόριθμος Μεταβλητών Ταχυτήτων**

Βασίζεται στην τεχνική του διπλασιασμού όπως και ο αλγόριθμος του Sinclair. Καθυστερεί το
διπλασιασμό βημάτων ανάλογα με το id της διεργασίας το πότε θα αποσταλλεί το id του καθενός
(όσο μεγαλύτερο το id τόσο μεγαλύτερη καθυστέρηση.)..

- Αρχηγός εκλέγεται η διεργασία με το μικρότερο ID
- Η βασική ιδέα του αλγορίθμου βρίσκεται στη διαφοροποίηση της “ταχύτητας” με την οποία
    τα μηνύματα “ταξιδεύουν” στο δίκτυο.
- Συγκεκριμένα, τα μηνύματα μιας διεργασίας με μικρό ID ταξιδεύουν πιο γρήγορα από τα
    μηνύματα μια άλλης με μεγαλύτερο ID.
- Μία διεργασία εκλέγεται αρχηγός όταν το μήνυμα με την ταυτότητά της κάνει το γύρο του
    δικτύου και επιστρέψει στην ίδια διεργασία.
- Το μήνυμα μιας διεργασίας με ταυτότητα i ταξιδεύει στο δίκτυο με καθυστέρηση 2i- 1
    γύρους. Οι διεργασίες, δηλαδή, που λαμβάνουν μήνυμα με τη ταυτότητα i, προωθούν το
    μήνυμα αυτό στον αριστερό γείτονά τους μετά από 2i-1 γύρους.

Η χρονική πολυπλοκότητα είναι n2m

H πολυπλοκότητα επικοινωνίας είναι O(n)


```
Lecture 9
```
Έμφαση στα βήματα των αλγόριθμων και στην πολυπλοκότητα τους

**Ποια τα κριτήρια για την αποδοχή ή όχι ενός αλγόριθμου αμοιβαίου αποκλεισμού**

Κριτήρια για την αποδοχή ή όχι ενός αλγορίθμου που λύνει το πρόβλημα του αμοιβαίου
αποκλεισμού είναι:

Ορθότητα (Correctness)
Ήτοι να ικανοποιούνται οι τρεις συνθήκες για ασφάλεια,βιωσιμότητα και διάταξη.

Πολυπλοκότητα επικοινωνίας (Communication Complexity)
Ελαχιστοποίηση των μηνυμάτων που διακινούνται κατά την επεξεργασία των αιτήσεων.

Απόκριση (Latency)
Ελαχιστοποίηση της καθυστέρησης εισόδου στην Κρίσιμη Περιοχή (ΚΠ)

**Ποια τα είδη αλγόριθμων αμοιβαίου αποκλεισμού**

Συγκεντρωτικός Αλγόριθμος Π.χ. Ο αλγόριθμος Συντονιστή (Coordinator)

Αλγόριθμοι διάταξης γεγονότων Πχ. Ο αλγόριθμος του Lamport, Ο αλγόριθμος των Ricard και
Agrawala

Αλγόριθμοι μεταβίβασης κουπονιού Πχ. (Ο αλγόριθμος του LeLann (τοπολογία δακτυλίου), Ο
αλγόριθμος του Chandy (οποιαδήποτε τοπολογία), Ο αλγόριθμος του Raymond (τοπολογία
δένδρου)

**Αλγόριθμος** Coordinator

Γενική λεκτική περιγραφή

Η διεργασία-συντονιστής Pc, η οποία επιλέγεται μέσω διαδικασίας εκλογής αρχηγού, ελέγχει την
πρόσβαση στον κοινό πόρο.

Ο συντονιστής Pc διατηρεί μία ουρά προτεραιότητας FIFO και δέχεται μέσω μηνυμάτων αιτήσεις
(μήνυμα request) για τον πόρο.

Όταν ο πόρος είναι ελεύθερος και η ουρά δεν είναι άδεια, ο συντονιστής Pc στέλνει ένα μήνυμα
(reply) στην διεργασία που είναι πρώτη στην ουρά να μπει στην Κρίσιμη Περιοχή (ΚΠ) και την
αφαιρεί από την ουρά.

Προκειμένου να απελευθερωθεί ο πόρος, η διεργασία που τον έχει στέλνει ένα μήνυμα (release)
στον συντονιστή Pc.

Συνεπώς υπάρχουν 3 τύποι μηνυμάτων: request, reply και release.

Αλγοριθμική περιγραφή
Αν μία διεργασία Pi θέλει πρόσβαση στην ΚΠ στέλνει <request, i> στον Pc
Όταν ο Pc λάβει <request, i>
αν καμία διεργασία δεν είναι στην ΚΠ τότε στέλνει <reply> στην Pi
αλλιώς εισάγει την Pi στην ουρά


Όταν η Pi βγεί από την ΚΠ στέλνει <release, i> στον Pc
αν η ουρά δεν είναι άδεια ο Pc στέλνει <reply> σε μια διεργασία της ουράς
Αν μία διεργασία Pi λάβει <reply> από τον Pc εισέρχεται στην ΚΠ

**Αλγόριθμος** Lamport

Γενική λεκτική περιγραφή

Κάθε διεργασία κρατάει ένα λογικό ρολόι και μία ουρά για εισερχόμενες αιτήσεις.

Κάθε διεργασία που επιθυμεί να μπει στην ΚΠ στέλνει ένα μήνυμα request σε όλες τις άλλες
διεργασίες. Το μήνυμα περιέχει και την χρονοσφραγίδα (Timestamp-TS) του λογικού ρολογιού της
διεργασίας. Η αίτησή της θα μπει και στην δική της ουρά.

Όταν μία διεργασία παραλάβει μία αίτηση, την τοποθετεί στην ουρά και απαντάει στην αιτούσα
διεργασία ότι η παραλαβή έγινε επιτυχώς.

Αν η ουρά δεν είναι κενή και ο πόρος είναι ελεύθερος οι διεργασίες αποφασίζουν να μπει στην ΚΠ
η διεργασία με την μικρότερη χρονοσφραγίδα, δηλαδή αυτή που έκανε πρώτα την αίτηση
σύμφωνα με την σχέση συνέβη πριν. (Όλες οι διεργασίες έχουν ίδιες ουρές άρα όλες αποφασίζουν
το ίδιο – στην πραγματικότητα η διεργασία που θα δει ότι στην ουρά της η αίτηση με την μικρότερη
χρονοσφραγίδα είναι δικιά της θα μπει στην ΚΠ).

Για την απελευθέρωση του πόρου η διεργασία που τον έχει, στέλνει μήνυμα release σε όλες τις
υπόλοιπες και διαγράφει την αίτησή της από την ουρά της. Όταν και οι άλλες διεργασίες
παραλάβουν το μήνυμα θα διαγράψουν και αυτές την αίτηση της διεργασίας από την ουρά τους
και θα συνεχιστεί η διαδικασία.

Αλγοριθμική περιγραφή

Αν η Pi θέλει να εισέλθει στην ΚΠ
εισάγει την αίτησή της στην ουρά της
στέλνει <request, i, TS> σε όλες τις υπόλοιπες διεργασίες
Αν η Pi λάβει <request, i, TS> από την Pj
βάζει την Pj στην ουρά προτεραιότητας με βάση το TS
στέλνει <reply> στην Pj
Αν η Pi θέλει να εξέλθει από την ΚΠ
διαγράφει την αίτησή της από την ουρά της
στέλνει <release> σε όλες τις υπόλοιπες διεργασίες
Αν η Pi λάβει <release> από την Pj
διαγράφει την Pj από την ουρά της
Η Pi εισέρχεται στην ΚΠ αν και μόνο αν:

1. έχει λάβει <reply> από όλες τις υπόλοιπες διεργασίες
2. η αίτησή της είναι στην κορυφή της ουράς της

Πολυπλοκότητα

Αυτός ο αλγόριθμος δημιουργεί 3 (N - 1) μηνύματα ανά αίτημα ή (N - 1) μηνύματα και 2 εκπομπές.
3 (N - 1) μηνύματα ανά αίτημα περιλαμβάνουν:

(N - 1) συνολικός αριθμός αιτημάτων
(N - 1) συνολικός αριθμός απαντήσεων
(N - 1) συνολικός αριθμός releases


**Αλγόριθμος** Ricard Agrawala

Αλγοριθμική περιγραφή

Κάθε διεργασία που επιθυμεί να μπει στην ΚΠ στέλνει αίτηση (request)
προς όλες τις άλλες διεργασίες
Μόλις μία διεργασία παραλάβει αίτηση (μήνυμα request) από μία άλλη
Αν βρίσκεται στην ΚΠ εισάγει την αίτηση στην ουρά της
Διαφορετικά:
Αν δεν ενδιαφέρεται για την ΚΠ στέλνει <OK>
Αν έχει εκδώσει και αυτή αίτηση με χρονοσφραγίδα TSj:
Αν TSi < TSj στέλνει <OK>
Αλλιώς εισάγει την αίτηση στην ουρά της
Η διεργασία θα μπει στην ΚΠ μόλις πάρει μήνυμα <OK> από όλες τις άλλες
Όταν η διεργασία εξέλθει από την ΚΠ
Στέλνει <OK> στις διεργασίες στην ουρά της
Διαγράφει όλες τις διεργασίες από την ουρά της
Με αυτόν τον τρόπο δεν χρειάζονται τα μηνύματα <release> καθώς τα κριτήρια για να γίνει η
πρόσβαση θα ικανοποιηθούν μόνο όταν ο πόρος είναι ελεύθερος

Πολυπλοκότητα

Ο αλγόριθμος Ricart – Agrawala απαιτεί επίκληση 2 (N - 1) μηνυμάτων ανά εκτέλεση κρίσιμης
ενότητας. Αυτά τα 2 (N - 1) μηνύματα περιλαμβάνουν

(N - 1) μηνύματα αιτήματος

(N - 1) μηνύματα απάντησης

**Αλγόριθμος** LeLann

Αλγοριθμική περιγραφή

Φάση αρχικοποίησης:

- Δημιουργία εικονικού δακτυλίου (λογική διάταξη των διεργασιών)
- Εκλογή αρχηγού με σκοπό η εκτέλεση του αλγορίθμου να αρχίσει από την διεργασία που
    θα εκλεγεί.
- Η διεργασία αρχηγός δημιουργεί ένα ειδικό μήνυμα – «κουπόνι». Μια διεργασία Pi μπορεί
    να μπει στη ΚΠ μόνον όταν έχει το κουπόνι
- Όταν μία διεργασία Pj λαμβάνει το κουπόνι αν θέλει μπορεί να το χρησιμοποιήσει για να
    εισέλθει στην ΚΠ μία μόνο φορά αλλιώς το προωθεί στον δεξιόστροφο γείτονά της
- Όταν μια διεργασία Pj βγει από την ΚΠ απελευθερώνει το κουπόνι και το προωθεί στο
    δεξιόστροφο γείτονά της.
- Συνεχίζεται η περιφορά του κουπονιού στον δακτύλιο και όποια διεργασία θέλει κρατά το
    κουπόνι όταν της έρθει και εισέρχεται στην ΚΠ


**Αλγόριθμος** Chandy

Διαφορές με LeLann

- Δεν έχουμε την άσκοπη περιφορά του κουπονιού όταν καμία διεργασία δεν το χρειάζεται
- Δεν απαιτείται καμία ειδική τοπολογία.
- Κάθε διεργασία πρέπει να ξέρει τα IDs των άλλων
- Το κουπόνι μεταφέρεται από την διεργασία που το είχε τελευταία σε αυτήν που το ζήτησε.
- Δεν υπάρχει λογική διάταξη των διεργασιών
- Το κουπόνι είναι ένα διάνυσμα F = (f1, f2,..., fN)
- fi = πόσες φορές η Pi χρησιμοποίησε την ΚΠ
- Κάθε διεργασία διατηρεί μια ουρά αιτήσεων

Αλγοριθμική περιγραφή

H Pi θέλει να μπει στην ΚΠ στέλνει <request Pi, mi> στις Ν-1 διεργασίες (mi: δηλώνει ότι η
διεργασία Pi θέλει να μπει στην ΚΠ για mi-οστή φορά) περιμένει το κουπόνι

Η Pj λαμβάνει <request Pi, mi>

```
Αν δεν κατέχει το κουπόνι εισάγει την αίτηση στην ουρά της
```
```
Αν κατέχει το κουπόνι
```
```
Αν δεν είναι σε ΚΠ στέλνει το κουπόνι στην Pi
```
```
Αν είναι σε ΚΠ εισάγει την αίτηση στην ουρά της
```
Η Pi λαμβάνει το κουπόνι

```
θέτει fi = mi μπαίνει στη ΚΠ
```
Η Pi ολοκληρώνει την εκτέλεση της ΚΠ

```
αν η ουρά αιτήσεων είναι κενή κρατά το κουπόνι μέχρι να λάβει νέα αίτηση
```
```
αν η ουρά αιτήσεων δεν είναι κενή εξάγει το πρώτο <request Pj, mj> από την ουρά
```
while (mj ≤ fj ) and (queue is not empty) do

```
/* παλιές αιτήσεις που ήδη έχουν εξυπηρετηθεί
```
```
εξάγει το επόμενο <request Pj, mj > από την ουρά
```
Εάν mj > fj στέλνει το κουπόνι στην Pj

Πολυπλοκότητα: 0 έως n μηνύματα (και για είσοδο, και για όλη τη διαδικασία)

**Αλγόριθμος** Raymond

Γενική λεκτική περιγραφή

Φάση αρχικοποίησης:

Όλες οι διεργασίες κατασκευάζουν ένα επικαλυπτικό δέντρο. Η ρίζα μπορεί να επιλεγεί τυχαία. Το
δέντρο θα έχει κατευθυνόμενες ακμές με κατεύθυνση από τα παιδιά προς τους γονείς.

Η ρίζα αναλαμβάνει να δημιουργήσει ένα ειδικό μήνυμα – κουπόνι.


Όταν κάποια διεργασία θέλει να κάνει αίτηση για είσοδο στην ΚΠ πρέπει να το δηλώσει στην ρίζα.
Αυτή με την σειρά της στέλνει στην διεργασία το κουπόνι. Το κουπόνι για να πάει στην διεργασία
που το ζήτησε διατρέχει κάποιες ακμές των οποίων αλλάζει την κατεύθυνση. Με αυτό τον τρόπο
μετά από την παράδοση του κουπονιού η διεργασία που έκανε την αίτηση θα είναι πλέον η ρίζα
του δέντρου.

Κάθε διεργασία διατηρεί ένα δείκτη προς το μονοπάτι που οδηγεί στην ρίζα πρακτικά δηλαδή
προς τον γονέα της την δεδομένη στιγμή που τρέχει ο αλγόριθμος, ενώ κρατάει και μία ουρά για το
ποιες διεργασίες (συμπεριλαμβανομένου και του εαυτού της) έχουν κάνει αίτηση για να πάρουν το
κουπόνι.

Αλγοριθμική περιγραφή

Η Pi θέλει να μπει στη ΚΠ:

Εισάγει την Pi στην ουρά της

Αν η ουρά της ήταν κενή

```
στέλνει <request Pi> στo γονέα της
```
Αν η ουρά της δεν ήταν κενή

```
περιμένει (έχει ήδη κάνει άλλη αίτηση)
```
Η Pj λαμβάνει <request Pi>:

```
αν δεν είναι η ρίζα
```
```
Συμπεριφέρεται όπως παραπάνω
```
```
αν είναι η ρίζα
```
```
αν δεν βρίσκεται στην ΚΠ
```
```
αντιστρέφει τη φορά της ακμής από την οποία πήρε το <request Pi>
```
στέλνει το κουπόνι στην Pi μέσω της αντεστραμμένης ακμής

```
αν βρίσκεται στην ΚΠ
```
```
εισάγει την Pi στην ουρά της
```
Η Pj λαμβάνει το κουπόνι:

```
εξάγει την Pk που βρίσκεται στην κεφαλή της ουράς της
```
```
Αν η Pk είναι ο εαυτός της
```
```
Εισέρχεται στην κρίσιμη περιοχή της
```
```
Αν η Pk δεν είναι ο εαυτός της
```
αντιστρέφει τη φορά της ακμής προς την Pk

στέλνει το κουπόνι στην Pk


```
Εάν η ουρά της δεν είναι ακόμη άδεια στέλνει <request Pj> προς την Pk
```
```
H Pj βγαίνει από την κρίσιμη περιοχή της
```
```
Aν η ουρά της δεν είναι άδεια
```
εξάγει την Pk που βρίσκεται στην κεφαλή της

αντιστρέφει τη φορά της προς την Pk

Στέλνει το κουπόνι προς την Pk

Aν η ουρά της δεν είναι ακόμη άδεια

```
στέλνει <request Pj> προς την Pk
```
Πολυπλοκότητα

Ο αλγόριθμος του Raymond είναι εγγυημένα O (log n) ανά κρίσιμη περιοχή, εάν οι επεξεργαστές
είναι οργανωμένοι σε ένα δέντρο με όχι περισσότερα από Κ παιδιλα ανά κόμβο. Επιπλέον, κάθε
επεξεργαστής πρέπει να αποθηκεύει το πολύ O (log n) bits επειδή πρέπει να παρακολουθεί O (1)
γείτονες.

```
Lecture 10 - 11
```
**Ποιοι οι τύποι σφαλμάτων σε επεξεργαστές;**

Αθόρυβα λάθη (Fail-silent faults)

Ο επεξεργαστής ο οποίος έχει το σφάλμα δεν ανταποκρίνεται. Σταματά να λειτουργεί.
Ονομάζονται και fail-stop faults.

Βυζαντινά λάθη (Byzantine faults)

Ο επεξεργαστής στον οποίο υπάρχει σφάλμα συνεχίζει τη λειτουργία του και είναι δυνατό να δίνει
λάθος απαντήσεις σε ερωτήματα. Πολλές φορές δίνεται η εντύπωση ότι το σύστημα λειτουργεί
σωστά.

**Τι είναι ένας** cluster **και ποιες οι διαφορετικές κατηγορίες του.**

Συστοιχίες υπολογιστών

Με τον όρο συστοιχία υπολογιστών αναφερόμαστε σε ένα πλήθος από κοινούς υπολογιστές,
διασυνδεδεμένους με κάποιο δίκτυο δίκτυο μεταξύ τους,οποίοι με τη χρήση κατάλληλου
λογισμικού μπορούν να συνεργαστούν στην επίλυση υπολογιστικών προβλημάτων.
Οι συστοιχίες αποτελούν το επόμενοβήμα μετά τους υπερυπολογιστές των προηγούμενων
δεκαετιών.
Χαμηλό κόστος
Μεγάλες δυνατότητες σημερινών υπολογιστών
Αύξηση ταχύτητας δικτύων
Απαίτηση για επεκτασιμότητα


Διαθεσιμό (δωρεάν) λογισμικό

Τύποι συστοιχιών υπολογιστών

Υπάρχουν τρεις βασικοί τύποι συστοιχιών υπολογιστών, οι οποίοι
χρησιμοποιούνται για διαφορετικούς σκόπους και
λειτουργούν με διαφορετικό τρόπο:

1. Fail-over {High-availabilίty): τα μέλη της συστοιχίας παρακολουθούν συνεχώς αν είναι
    διαθέσιμες κάποιες συγκεκριμένες υπηρεσίες. Όταν κάποια από αυτές τις υπηρεσίες για
    κάποιο λόγο σταματήσει να είναι διαθέσιμη, τα μέλη της συστοιχίας επεμβαίνουν
2. Load-balancing: όταν φτάσει ένα αίτημα σε κάποια υπηρεσία που
    προσφέρει η συστοιχία, η εξυπηρέτησή του ανατίθεται στον υπολογιστή που εχει το
    μικροτερο φορτο.
3. High Performance Computing (Beowulf): Χρησιμοποιείται σε 'δύσκολα' υπολογιστικά
    προβλήματα, όπου γίνεται διάσπαση του προβλήματος σε υποπροβλήματα και
    διαμοιρασμός τους μέσω λογισμικού στα μέλη της συστοιχίας

**Ποια τα βασικά χαρακτηριστικά σχεδιασμού του** cluster.

Cluster Computers
Οι clusters είναι ένα σύμπλεγμα υπολογιστών αποτελούμενο από διασυνδεδεμένους αυτόνομους
υπολογιστές που λειτουργούν συνεργατικά ως ένας ολοκληρωμένος υπολογιστικός πόρος.
Οι clusters παρουσιάζουν εντυπωσιακή επίδοση στον χερισμό μεγάλου φόρτου με μεγάλα σύνολα
από δεδομένα.
Συνήθως κατασκευάζονται γύρω από ένα διασυνδεδεμένο δίκτυο υψηλού εύρους ζώνης , χαμηλής
καθυστέρησης. Το δίκτυο αυτό μπορεί να είναι τοπικό (LAN) ή ένα dedicated δίκτυο αποθήκευσης
(SAN).
Για να δημιουργήθεί ένας μεγαλύτερος cluster με περισσότερους κόμβους,το δίκτυο διασύνδεσης
μπορεί να δημιουργηθεί με πολλαπλά επίπεδα( Gigabit Ethernet, Myrinet ή InfiniBand switches).

Στόχοι των συστημάτων συστοιχίας υπολογιστών

Επεκτασιμότητα (αρθρωτή)

Τμηματοποίηση (χαλαρή ή συμπαγής)

Έλεγχος (συγκεντρωτικός ή αποκεντρωμένος)

Ομοιογένεια (ομοιογενής ή ετερογενής)

Ασφάλεια (εκτεθειμένη ή κλειστή)

Βασικά χαρακτηριστικά σχεδιασμού του cluster

Ομαδοποίηση για μαζικό παραλληλισμό

Επεκτάσιμη απόδοση

Εικόνα ενός συστήματος (SSI)

Υποστήριξη Διαθεσιμότητας

Διαχείριση εργασίας cluster


Επικοινωνία μεταξύ κόμβων

Ανοχή και αποκατάσταση σφαλμάτων

**Χρονοδρομολόγηση**

Στη λειτουργία χρονοδρομολόγησης, πολλές διαδικασίες χρήστη αντιστοιχίζονται στον ίδιο κόμβο.

Πολιτικές προγραμματισμού:

Ανεξάρτητος (ή τοπικός) προγραμματισμός.
H πιο απλή υλοποίηση της χρονοδρομολόγησης είναι η χρήση του λειτουργικού συστήματος του
κάθε κόμβου του cluster για τον προγραμματισμό διαφορετικών διαδικασιών όπως σε έναν
παραδοσιακό σταθμό εργασίας. Ωστόσο, η απόδοση των παράλληλων εργασιών θα μπορούσαν
να υποβαθμιστούν σημαντικά, δεδομένου ότι οι διεργασίες μίας παράλληλης εργασίας πρέπει να
αλληλεπιδράσουν.

Προγραμματισμός gang. Το Gang scheduling προγραμματίζει όλες τις διαδικασίες μιας
παράλληλης εργασίας μαζί. Όταν μια διαδικασία είναι ενεργή, όλες οι διαδικασίες είναι ενεργές.
Οι κόμβοι του cluster δεν είναι τέλεια συγχρονισμένοι με το ρολόι. Ο χρόνος εκτέλεσης μίας
παραλλήλης δουλειάς αυξάνεται καθώς όσο η καμπύλη του gang scheduling μεγαλώνει,
θα πρέπει να χρησιμοποιθεί ένας ομοιογενής cluster, όπου το gang scheduling είναι πιο
αποτελεσματικό. Ωστόσο, το gang scheduling δεν έχει γίνει αντιληπτό στους περισσότερους
clusters λόγω δυσκολιών εφαρμογής.

**Αρχιτεκτονικές** Fault tolerance

Fault-Tolerant Cluster Configurations

Τρία ανερχόμενα επίπεδα διαθεσιμότητας:

καυτή κατάσταση αναμονής, ενεργή ανάληψη και ανοχή σε σφάλματα

Τρία θέματα ενδιαφέροντος:

χρόνος ανάκτησης, δυνατότητα επιστροφής και δραστικότητα κόμβων

Το επίπεδο διαθεσιμότητας αυξάνεται από κατάσταση αναμονής σε ενεργό και fault tolerant

διαμορφωμένο cluster. Όσο μικρότερος είναι ο χρόνος ανάκτησης, τόσο υψηλότερη είναι η


διαθεσιμότητα του cluster.

Η δυνατότητα επιστροφής αναφέρεται στην ικανότητα ενός ανακτημένου κόμβου στην κανονική

λειτουργία μετά την επισκευή ή συντήρηση.

Η δραστικότητα της διαθεσιμότητας αυξάνεται από την κατάσταση αναμονής

Σε ενεργή και αναφέρεται στο εάν ο κόμβος χρησιμοποιείται σε ενεργή εργασία κατά τη διάρκεια

της κανονικής λειτουργίας

Καυτή κατάσταση αναμονής - Hot standby server clusters

Σε ένα Hot standby server cluster, μόνο ο κύριος κόμβος κάνει ενεργά όλη την χρήσιμη εργασία

κανονικά. Ο κόμβος αναμονής είναι ενεργοποιημένος (hot) και εκτελεί ορισμένα προγράμματα

παρακολούθησης για την επικοινωνία σημάτων ζωής για τον έλεγχο της κατάστασης του

πρωτεύοντος κόμβου, αλλά δεν είναι σε ενεργή χρήση.

Ο κύριος κόμβος πρέπει να αντικατοπτρίζει τυχόν δεδομένα σε κοινόχρηστο χώρο αποθήκευσης

δίσκου

Ενεργή ανάληψη - Active-takeover clusters

Σε αυτήν την περίπτωση, η αρχιτεκτονική είναι συμμετρική μεταξύ πολλών κόμβων διακομιστή.

Και οι δύο διακομιστές είναι πρωταρχικοί, κάνοντας χρήσιμη εργασία κανονικά. Όταν ένας κόμβος

αποτύχει, οι εφαρμογές χρήστη αποτυγχάνουν στον διαθέσιμο κόμβο του συμπλέγματος.

Οι χρήστες ενδέχεται να αντιμετωπίσουν καθυστερήσεις ή ενδέχεται να χάσουν ορισμένα

δεδομένα κ.λπ.

Ανοχή σε σφάλματα - Failover / Fault tolerant clusters.

Απώλεια στοιχείων συστήματος / υλικού. Αυτό είναι ίσως το πιο σημαντικό χαρακτηριστικό που

απαιτείται στους τρέχοντες clusters για εμπορικές εφαρμογές. Όταν ένα στοιχείο αποτύχει, το

υπόλοιπο σύστημα είναι σε θέση (λόγω περιττών στοιχείων) να αναλάβει τις υπηρεσίες που

παρείχε αρχικά το αποτυχημένο στοιχείο.


**Πρωτοκολλα κατανεμημένης δέσμευσης** 2 PC- 3 PC **.Που κολλάει το ένα και ποια**

**προβλήματα λύνει το** 2 **ο**^

```
Πρωτόκολλο Δέσμευσης Τριών Φάσεων 2 PC
```
Το πρωτόκολλο αποτυγχάνει αν μια διεργασία καταρρεύσει ενώ οι άλλες περιμένουν μήνυμα

απ’αυτήν.

Λύση: Χρησιμοποιούνται μηχανισμοί χρονικών προθεσμιών

Παραδείγματα

Ο συντονιστής μπορεί να μπλοκαριστεί στην κατάσταση WAIT. Αν δεν λάβει όλες τις ψήφους

έπειτα από κάποιο διάστημα στέλνει σε όλους GLOBAL_ABORT.

Ένας συμμετέχων P μπορεί να μπλοκαριστεί στην κατάσταση READY. Δεν μπορεί να ματαιώσει

αμέσως τοπικά τη συναλλαγή. Πρέπει να διαπιστώσει ποιο μήνυμα έστειλε ο συντονιστής.

Λύση: Ο P επικοινωνεί με άλλον συμμετέχοντα Q για να εξετάσει αν μπορεί να αποφασίσει με
βάση την τρέχουσα κατάσταση του Q.

Αστοχίες στις διεργασίες

Αν διαπιστωθεί ότι όλοι οι συμμετέχοντες βρίσκονται στην κατάσταση READY δεν μπορεί να
ληφθεί καμία απόφαση έως ότου ανακάμψει ο συντονιστής.

Προκειμένου οι διεργασίες να μπορούν πραγματικά να ανακάμπτουν θα πρέπει να καταγράφουν
την κατάστασή τους.

Μπλοκάρισμα» στο 2PC

Αν όλοι οι συμμετέχοντες βρίσκονται στην κατάσταση READY δεν μπορεί να ληφθεί καμία
απόφαση έως ότου ανακάμψει ο συντονιστής.

Στην περίπτωση αυτή οι συμμετέχοντες «μπλοκάρονται» και γι’ αυτό το 2PC καλείται και
Πρωτόκολλο Δέσμευσης με Μπλοκάρισμα (blocking commit protocol)

Λύση #1: Κάθε αποδέκτης ενός μηνύματος στέλνει αμέσως με πολυεκπομπή σε όλες τις άλλες
διεργασίες κάθε μήνυμα που λαμβάνει. Η προσέγγιση αυτή επιτρέπει στους συμμετέχοντες να
καταλήξουν σε απόφαση ακόμη και αν ο συντονιστής δεν έχει ανακάμψει.

Λύση #2: Πρωτόκολλο δέσμευσης τριών φάσεων (3PC)


```
Πρωτόκολλο Δέσμευσης Τριών Φάσεων (3PC)
```
Οι καταστάσεις του συντονιστή και κάθε συμμετέχοντα ικανοποιούν τις εξής δύο συνθήκες:

Δεν υπάρχει καμία κατάσταση από την οποία να είναι δυνατή η απευθείας μετάβαση είτε σε μια

κατάσταση COMMIT ή σε μια κατάσταση ABORT.

Δεν υπάρχει καμία κατάσταση από την οποία να μην είναι δυνατό να ληφθεί μια τελική απόφαση,

και από την οποία να μπορεί να πραγματοποιηθεί μετάβαση σε μια κατάσταση COMMIT.

Οι δύο αυτές συνθήκες είναι αναγκαίες και ικανές για την ύπαρξη ενός πρωτοκόλλου δέσμευσης

χωρίς μπλοκάρισμα. Η βασική ιδέα είναι ότι στο διάγραμμα κατάστασης που οδηγεί σε commit, ο

συντονιστής και οι συμμετέχοντες να μην διαφέρουν περισσότερο από μία κατάσταση.

Αστοχίες στις διεργασίες

Ο συντονιστής μπλοκάρεται στην κατάσταση WAIT. Αν δεν λάβει όλες τις ψήφους έπειτα από

κάποιο διάστημα στέλνει σε όλους GLOBAL_ABORT.

Ο συντονιστής μπλοκάρεται στην κατάσταση PRECOMMIT διότι ένας από τους συμμετέχοντες

(έστω ο p) έχει καταρρεύσει: ο συντονιστής μπορεί να στείλει στους υπόλοιπους

GLOBAL_COMMIT διότι ο p έχει ήδη ψηφίσει υπέρ της δέσμευσης και όταν ανακάμψει θα

ολοκληρώσει τη δέσμευση.Ένας συμμετέχων P μπορεί να μπλοκαριστεί στην κατάσταση READY

ή στην PRECOMMIT.

Δεν μπορεί να ματαιώσει αμέσως τοπικά τη συναλλαγή. Πρέπει να διαπιστώσει ποιο μήνυμα

έστειλε ο συντονιστής.

Λύση: Ο P επικοινωνεί με άλλον συμμετέχοντα Q για να εξετάσει αν μπορεί να αποφασίσει με

βάση την κατάσταση του Q. Αν κάθε συμμετέχων με τον οποίο μπορεί να επικοινωνήσει ο P

βρίσκεται στην κατάσταση READY τότε η συναλλαγή ματαιώνεται.

Κανένας συμμετέχων που βρίσκεται σε λειτουργία, δεν γνωρίζει ποια θα είναι η κατάσταση του

συμμετέχοντα που κατέρρευσε όταν αυτός ανακάμψει:

Αν ανακάμψει στην INIT η μόνη σωστή απόφαση είναι η ματαίωση της συναλλαγής.

Αν ανακάμψει στην PRECOMMIT και πάλι η ματαίωση της συναλλαγής δεν δημιουργεί πρόβλημα.

Αυτή η περίπτωση **αποτελεί τη μεγαλύτερη διαφορά από το 2PC** όπου ένας συμμετέχων θα

μπορούσε να ανακάμψει στην COMMIT ενώ όλοι οι άλλοι βρίσκονται στην READY.

Αν κάθε συμμετέχων με τον οποίο μπορεί να επικοινωνήσει ο P βρίσκεται στην κατάσταση

PRECOMMIT τότε είναι ασφαλές να δεσμευθεί η συναλλαγή.

Όλες οι άλλες θα ανακάμψουν στην κατάσταση READY, PRECOMMIT ή COMMIT που

βρίσκονταν κατά τη στιγμή της κατάρρευσής τους.



= Υπολογιστική Νέφους και Υπηρεσίες
:source-language: java

.ΕΡΓΑΣΙΑ 1: CLOUDSIM
[NOTE]
****
[.text-center]

Η πρώτη εργασία του μαθήματος "Υπολογιστική Νέφους και Υπηρεσίες" απαιτεί την εφαρμογή του πλατφόρμας Cloudsim, 
η οποία προσομοιώνει την ανάπτυξη και την εκτέλεση υπολογιστικών εφαρμογών σε νέφος υπολογιστικής.
****

*Φοιτητής*: +
Μαριος Παπαζογλου - ice21390179


== Εισαγωγή
Το Cloudsim είναι ένα εκτεταμένο framework προσομοίωσης, το οποίο παρέχει στους χρήστες τη δυνατότητα πλήρους έλεγχου και ανάλυσης ενός περιβάλλοντος νέφους (cloud).
Με το Cloudsim, ο χρήστης μπορεί να δημιουργήσει, να προσομοιώσει και να αξιολογήσει το δικό του cloud περιβάλλον, καθώς και να αναπτύξει τις δικές του λύσεις βασισμένες σε αυτό.
Μέσω του Cloudsim, ο χρήστης έχει τη δυνατότητα να μελετήσει την απόδοση,
την αποδοτικότητα και την κλιμακωσιμότητα του cloud περιβάλλοντος του, εξετάζοντας διάφορες παράμετρους και συνθήκες.


== Ανάλυση CloudExample6

Στο παράδειγμα CloudExample6, δημιουργούνται δύο datacenters με δύο hosts σε κάθε ένα.
Η δημιουργία των datacenters γίνεται μέσα στην main μέθοδο, ενώ η μέθοδος createDatacenter χρησιμοποιείται για να δημιουργηθούν τα δύο datacenters, 
έχοντας κάθε ένα από αυτά δύο hosts. Κάθε host σε κάθε datacenter διαθέτει συγκεκριμένα χαρακτηριστικά. Για παράδειγμα, ο host 0, είτε βρίσκεται στο πρώτο είτε στο δεύτερο datacenter,
διαθέτει 4 επεξεργαστές, ενώ ο host 1 έχει 2 επεξεργαστές. Όσον αφορά τα υπόλοιπα χαρακτηριστικά, είναι ίδια για κάθε host, όπως 2048 MB κύρια μνήμη (RAM), 10 MB αποθηκευτικό χώρο (storage), 
10 KB εύρος ζώνης (bandwidth) και χρήση ενός συγχρονιστή χρόνου που επιτρέπει την παράλληλη εκτέλεση εργασιών στον host.

Μετά τη δημιουργία των hosts, δημιουργείται ένας broker στην main μέθοδος, ο οποίος αναλαμβάνει τη διαχείριση των εικονικών μηχανών (VM). 
Στη συνέχεια, δημιουργούνται 20 εικονικές μηχανές με συγκεκριμένα χαρακτηριστικά. Κάθε VM έχει μέγεθος 100 KB και απαιτεί 512 MB κύρια μνήμη για να λειτουργήσει.

[cols="1, 1, 1"]
|===
| Virtual Machine | Host | Datacenter
| 0, 1, 2, 4 | 0 | 1
| 3, 5 | 1 | 1
| 6, 7, 8, 10 | 0 | 2
| 9, 10 | 1 | 2
|===

NOTE: Αυτός ο πίνακας αλλάζει αναλόγως τον αλγόριθμο.

Μετά τη δημιουργία των VM, ξεκινά η δημιουργία των cloudlets, συνολικά 40. Τα χαρακτηριστικά των cloudlets είναι: μέγεθος 1000, μέγεθος συστήματος 300, μέγεθος output 300 και μονοπύρηνο.
Χρησιμοποιείται το UtilizationModel για τον έλεγχο των πόρων, ενώ ο broker αναλαμβάνει την διαχείρισή τους.

Όσον αφορά την αντιστοίχιση cloudlet/vm, ο broker στέλνει ένα-ένα cloudlet σε όλα τα VM. Με 40 cloudlets που πρέπει να αντιστοιχιστούν σε 12 VM, αυτό σημαίνει ότι κάθε VM θα έχει 3 cloudlets, 
ενώ τα υπόλοιπα 4 cloudlets θα αντιστοιχιστούν στα πρώτα 4 VM.

Τέλος, στα τελικά αποτελέσματα επιστρέφονται οι παρακάτω πληροφορίες για κάθε cloudlet: το ID του, την κατάστασή του, το ID του datacenter που ανήκει το VM που φιλοξενεί το cloudlet, το ID του VM,
τον χρόνο που χρειάστηκε για την εκτέλεση του simulation, καθώς και την αρχική και την τελική ώρα. Οι cloudlets εκτελέστηκαν με τη σειρά που εισήχθησαν, με κάθε cloudlet να απαιτεί 1 δευτερόλεπτο για την
ολοκλήρωση της λειτουργίας του.

=== Εναλλακτικές δυνατότητες

Ο κώδικας έχει τροποποιηθεί για να υποστηρίζει τη λειτουργία space sharing αντί για time sharing. 
Αυτή η αλλαγή επηρεάζει τη δρομολόγηση των cloudlets στα εικονικά μηχανήματα (VM).

Πιο συγκεκριμένα, ο κώδικας αλλάζει τη μέθοδο που χρησιμοποιείται για τη δημιουργία των VM στους hosts. 
Αντί για την προηγούμενη μέθοδο που χρησιμοποιούσε time sharing, χρησιμοποιείται τώρα η μέθοδος space sharing. 
Αυτή η αλλαγή γίνεται με την προσθήκη του παραμέτρου new VmSchedulerSpaceShared(peList) στη δημιουργία του κάθε host.

Επίσης, η δρομολόγηση των cloudlets στα VM έχει τροποποιηθεί. Στο προηγούμενο κώδικα, ο broker αντιστοιχούσε κάθε cloudlet σε ένα VM με βάση την διαθεσιμότητα του πρώτου ελεύθερου VM στη λίστα.
Τώρα, η δρομολόγηση γίνεται με βάση τη σειρά που εισέρχονται τα cloudlets. Δηλαδή, το πρώτο cloudlet που μπαίνει στη λίστα θα αντιστοιχηθεί στο πρώτο διαθέσιμο VM,
το δεύτερο cloudlet στο δεύτερο διαθέσιμο VM και ούτω καθεξής. Αυτός ο αλγόριθμος δρομολόγησης είναι γνωστός ως First-In-First-Out (FIFO).

Συνολικά, οι αλλαγές στον κώδικα επιτρέπουν τη χρήση της μεθόδου space sharing για τη διαμοιρασμό των πόρων των VM, και την δρομολόγηση των cloudlets με βάση τη σειρά που εισέρχονται.

[source]
--
hostList.add(
        new Host(
            hostId,
            new RamProvisionerSimple(ram),
            new BwProvisionerSimple(bw),
            storage,
            peList1,
            new VmSchedulerSpaceShared(peList1)
        )
      ); // First machine

hostId++;

hostList.add(
        new Host(
            hostId,
            new RamProvisionerSimple(ram),
            new BwProvisionerSimple(bw),
            storage,
            peList2,
            new VmSchedulerSpaceShared(peList2)
        )
      ); // Second machine

vm[i] = new Vm(i, userId, mips, pesNumber, ram, bw, size, vmm, new CloudletSchedulerSpaceShared());
--

=== Ελάχιστες απαιτούμενες αλλαγές για να τρέχουν όλα τα VM

Επόμενο βήμα είναι να τροποποιήσουμε τον προσομοιωτή ώστε να εκτελούνται όλες οι εικονικές μηχανές (VM). Έχουμε δύο επιλογές για αυτή την τροποποίηση: 
είτε να παρέχουμε περισσότερη RAM στους υπολογιστικούς κόμβους (hosts), είτε να αυξήσουμε τον αριθμό των πυρήνων (cores) σε κάθε κόμβο. Ας επικεντρωθούμε αρχικά στην αύξηση της RAM.

Αρχικά, οι κόμβοι έχουν 2048 MB RAM. Προς το παρόν, επτά VM δεν μπορούν να εκτελεστούν λόγω έλλειψης μνήμης. Χρειάζεται συνολικά 3584 MB πρόσθετης RAM για να εκτελεστούν αυτά τα VM.
Για να επιτευχθεί αυτό, θα πρέπει να προστεθούν τουλάχιστον 1792 MB RAM ανά κόμβο, έτσι ώστε η τελική RAM ανά κόμβο να φτάσει τα 3840 MB RAM.

Επιπλέον, παρατηρούμε ότι κάθε CPU μπορεί να εκτελέσει 1000 εντολές ανά δευτερόλεπτο, το ίδιο όπως και η κάθε VM. 
Υπάρχουν 6 περισσεύοντα VM, δηλαδή 6000 MIPS. Συνεπώς, θα πρέπει να αυξήσουμε τα MIPS σε 2000 για 4 τυχαίους επεξεργαστές (CPUs), ώστε κάθε επεξεργαστής να μπορεί να εκτελέσει περισσότερες VM. 
Αυτή η αλλαγή θα επιτρέψει την εξυπηρέτηση των περισσευόμενων VM που πριν δεν μπορούσαν να εκτελεστούν.

Ωστόσο, πρέπει να σημειωθεί ότι πρώτα θα φορτωθούν τα πρώτα 12 VM όπως πριν, και όταν μια θέση γίνει διαθέσιμη, θα τοποθετηθεί σε αυτήν μια νέα VM.
Για να αντιμετωπίσουμε αυτό το πρόβλημα, θα πρέπει να αυξήσουμε τον αριθμό των πυρήνων, προσθέτοντας 2 CPUs ανά κόμβο.

Στα αποτελέσματα των προσομοιώσεων, αρχικά χωρίς τους επιπλέον επεξεργαστές, δεν παρατηρείται μεγάλη διαφορά στην εκτέλεση.
Κάθε VM έχει διάρκεια 1 δευτερολέπτου, και αυτό ισχύει και για τους επιπλέον επεξεργαστές. Η διαφορά εμφανίζεται στον τελικό χρόνο εκτέλεσης. 
Αντί να ολοκληρώνεται σε 3.2 δευτερόλεπτα, ο χρόνος εκτέλεσης είναι πιο γρήγορος κατά 1 δευτερόλεπτο και ολοκληρώνεται σε 2.2 δευτερόλεπτα.

[source]
--
List<Pe> peList1 = new ArrayList<Pe>();

int mips1 = 2000;
int mips2 = 1000;

peList1.add(new Pe(0, new PeProvisionerSimple(mips1))); 
peList1.add(new Pe(1, new PeProvisionerSimple(mips1)));
peList1.add(new Pe(2, new PeProvisionerSimple(mips1)));
peList1.add(new Pe(3, new PeProvisionerSimple(mips2)));
peList1.add(new Pe(4, new PeProvisionerSimple(mips1)));
peList1.add(new Pe(5, new PeProvisionerSimple(mips1)));

//Another list, for a dual-core machine
List<Pe> peList2 = new ArrayList<Pe>();
peList2.add(new Pe(0, new PeProvisionerSimple(mips1)));
peList2.add(new Pe(1, new PeProvisionerSimple(mips2)));
peList2.add(new Pe(2, new PeProvisionerSimple(mips2)));
peList2.add(new Pe(3, new PeProvisionerSimple(mips2)));
--


=== Αλλαγή πολιτικής απόφασης για τα VM και τα Cloudlets

Για να αλλάξουμε τη στρατηγική αντιστοίχισης VMs σε hosts και Cloudlets σε VMs στον κώδικα του προσομοιωτή, μπορούμε να ακολουθήσουμε τις παρακάτω αλλαγές:

* Αλλαγή της στρατηγικής αντιστοίχισης VMs σε hosts:
** Ανοίξτε τον κώδικα του προσομοιωτή και βρείτε το σημείο όπου γίνεται η αντιστοίχιση των VMs στους υπολογιστικούς κόμβους (hosts). 
** Αλλάξτε τη στρατηγική από την τρέχουσα στρατηγική σε VmScheduleSpaceShared. Αυτή η στρατηγική επιτρέπει την κοινή χρήση του χώρου των κόμβων από πολλές VMs, επιτρέποντας έτσι την εκτέλεση περισσότερων VMs.

* Αλλαγή της στρατηγικής αντιστοίχισης Cloudlets σε VMs:
** Ανοίξτε τον κώδικα του προσομοιωτή και βρείτε το σημείο όπου γίνεται η αντιστοίχιση των Cloudlets στις VMs.
** Αλλάξτε τη στρατηγική από την τρέχουσα στρατηγική σε CloudletSchedulerDynamicWorkload. Αυτή η στρατηγική επιτρέπει τη δυναμική αντιστοίχιση των Cloudlets στις διαθέσιμες VMs, εξασφαλίζοντας την αποτελεσματική εκτέλεση των Cloudlets.

Με αυτές τις αλλαγές, η στρατηγική αντιστοίχισης VMs σε hosts θα είναι VmScheduleSpaceShared και η στρατηγική αντιστοίχισης Cloudlets σε VMs θα είναι CloudletSchedulerDynamicWorkload. Αυτές οι στρατηγικές θα επιτρέψουν την αποδοτική αξιοποίηση των διαθέσιμων πόρων και τη βελτιστοποίηση του χρόνου εκτέλεσης των Cloudlets.

[source]
--
hostList.add(
        new Host(
            hostId,
            new RamProvisionerSimple(ram),
            new BwProvisionerSimple(bw),
            storage,
            peList1,
            new VmSchedulerTimeShared(peList1)
        )
      ); // This is our first machine

hostId++;

hostList.add(
        new Host(
            hostId,
            new RamProvisionerSimple(ram),
            new BwProvisionerSimple(bw),
            storage,
            peList2,
            new VmSchedulerTimeShared(peList2)
        )
      ); // Second machine

vm[i] = new Vm(i, userId, mips, pesNumber, ram, bw, size, vmm, new CloudletSchedulerTimeShared());
--

Ας εξηγήσουμε τον κώδικα γραμμή προς γραμμή:

* Αρχικά, δημιουργούμε ένα νέο αντικείμενο Host και το προσθέτουμε στη λίστα hostList. Το αντικείμενο Host αποτελεί τον υπολογιστικό κόμβο (host) στον οποίο θα εκτελούνται οι εικονικές μηχανές (VMs). Παρέχουμε τιμές για τα απαιτούμενα χαρακτηριστικά του κόμβου, όπως η χωρητικότητα RAM, η εύρος ζώνης, ο χώρος αποθήκευσης και οι επεξεργαστικές μονάδες.
* Αυξάνουμε τον αριθμό hostId κατά ένα για τη δημιουργία του επόμενου κόμβου.
* Δημιουργούμε ένα νέο αντικείμενο Host για τον δεύτερο κόμβο και το προσθέτουμε στη λίστα hostList.
* Ακολούθως, δημιουργούμε ένα νέο αντικείμενο Vm για κάθε VM. Παρέχουμε τιμές για τα απαιτούμενα χαρακτηριστικά της VM, όπως η εύρος ζώνης, ο χώρος αποθήκευσης, ο αριθμός των επεξεργαστικών μονάδων και η μέθοδος αντιστοίχισης των Cloudlets.

Ο κώδικας προσθέτει δύο υπολογιστικούς κόμβους (Hosts) στη λίστα hostList και δημιουργεί μία VM για κάθε επανάληψη του βρόγχου for. Η παράμετρος i αναπαριστά τον αριθμό της κάθε VM και χρησιμοποιείται για την αναγνώρισή της.
Συνολικά, ο κώδικας παρέχει τα απαιτούμενα χαρακτηριστικά για τη δημιουργία των υπολογιστικών κόμβων και των εικονικών μηχανών στο περιβάλλον εκτέλεσης του simulator.

=== Αλλαγή πολιτικής αντιστοίχισης για τα VM και τα Cloudlets

Για να τροποποιήσουμε το μοντέλο αξιοποίησης (utilization model) για την αντιστοίχιση των VM και των Cloudlets, μπορούμε να αλλάξουμε το αντικείμενο UtilizationModel που χρησιμοποιείται.

Ας εξηγήσουμε πρώτα το UtilizationModelNull. Με αυτό το μοντέλο, το Cloudlet πάντα ζητάει μηδενική χωρητικότητα από τον υπολογιστικό κόμβο (host).
Στα αποτελέσματα, θα παρατηρήσετε ότι η διάρκεια εκτέλεσης κάθε Cloudlet έχει αυξηθεί κατά 1 δευτερόλεπτο. 
Αυτό σημαίνει ότι ένα Cloudlet παίρνει 2 δευτερόλεπτα για να ολοκληρωθεί.

Επιπλέον, υπάρχει το μοντέλο UtilizationModelStochastic, όπου κάθε Cloudlet παίρνει μια τυχαία τιμή αξιοποίησης σε κάθε χρονικό βήμα.
Αυτό επιτρέπει την προσομοίωση της μεταβαλλόμενης αξιοποίησης των πόρων από τα Cloudlets κατά τη διάρκεια της εκτέλεσής τους.

Για να τροποποιήσουμε τον κώδικα, αντικαταστήστε το αντικείμενο UtilizationModel με το επιθυμητό μοντέλο. 
Για παράδειγμα, μπορείτε να χρησιμοποιήσετε το UtilizationModelStochastic για να εισάγετε τυχαιότητα στην αξιοποίηση των πόρων των Cloudlets.

[source]
--
UtilizationModel utilizationModel = new UtilizationModelFull();
--
